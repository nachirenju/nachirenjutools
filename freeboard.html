<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>連珠盤</title>
  <style>
    body { font-family: sans-serif; }
    #controls { margin: 10px 0; }
    canvas { border: 1px solid #ccc; }
    label { margin-right: 10px; }
  </style>
</head>
<body>
  〇使い方<br>
  自由に置けるだけの盤です。私の<a href="https://www.youtube.com/channel/UCfbgN9hrrh9fmFKs8gxln5g">動画編集用</a>に作成しました。特殊な機能はありません。大会集計ツールは<a href="index.html">こちら</a><br>
  通常モードでは黒白交互に石を置けます。<br>
  左クリック→着手<br>
  右クリック→一手戻す<br>
  自由配置モードでは、<br>
  左クリック→黒石<br>
  右クリック→白石<br>
※自由配置モードをスマホやタブレットで操作時、上記ではうまく動かないので黒石白石の配置チェックボックスをお使いください。
  二回クリックすると石が消えます。
  <div id="controls">
    <button id="toggleModeBtn">自由配置モードに切替</button>
    <label><input type="radio" name="startColor" value="black" checked> 黒番開始</label>
    <label><input type="radio" name="startColor" value="white"> 白番開始</label>
    <button id="saveBoardPng">PNG保存</button>
    <button id="saveGifBtn">GIF保存</button>
    <br>
    <!-- ★ 追加部分 -->
    <label><input type="checkbox" id="inputNumber"> 数字を入力</label>
    <label><input type="checkbox" id="inputAlpha"> アルファベットを入力</label>
    <button id="clearLabels">入力文字削除</button>
    <br>
    <!-- ★ ここまで追加 -->
    <label>開始手数: <input type="number" id="gifStartMove" value="1" min="1"></label>
    <label>更新間隔(秒): <input type="number" id="gifInterval" value="0.5" step="0.1"></label>
    <label>最初フレーム静止(秒): <input type="number" id="gifFirstDelay" value="1" step="0.1"></label>
    <label>最終フレーム静止(秒): <input type="number" id="gifLastDelay" value="2" step="0.1"></label>
    <br><button id="generateLinkBtn">リンク生成＆コピー</button>
    <br>
    <input type="text" id="generatedLink" readonly style="width:60%;">
  </div>
  <br>
  <div id="board"></div>
  <div id="controls">
  <button id="undoAllBtn">全て戻す</button>
  <button id="undoBtn">一手戻す</button>
  <button id="redoBtn">一手進める</button>
  <button id="redoAllBtn">全て進める</button>
</div>
<div id="freeModeControls" style="display:none; margin-top:5px;">
  <label><input type="checkbox" id="placeBlack"> 黒石配置モード</label>
  <label><input type="checkbox" id="placeWhite"> 白石配置モード</label>
</div>


  <div style="margin-top:10px; text-align:left;">
    <textarea id="kifuInput" rows="3"
              style="width:40%; font-family:monospace;"
              placeholder="ここに棋譜を入力 (例: h8i9h10...)"></textarea>
  </div>

  <!-- コメント欄 -->
  <div style="margin-top:10px;">
    上段コメント:画像保存時、盤の上側に入力したテキストが表示されます。<br>
    <textarea id="commentTop" rows="2" style="width:60%;"></textarea>
  </div>
  <div style="margin-top:10px;">
    下段コメント:画像保存時、盤の下側に入力したテキストが表示されます。<br>
    <textarea id="commentBottom" rows="2" style="width:60%;"></textarea>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>

  <script>
    const size = 15;
    const cell = 30;
    const marginLeft = 25;
    const marginRight = 20;
    const marginTop = 60;
    const marginBottom = 60;

    let freeMode = false;
    let blackTurn = true;
    let moves = []; // {x, y, color, number}
    let boardState = Array.from({ length: size }, () => Array(size).fill(null));

    // ★ 追加: ラベル管理
    let labels = []; // {x,y,text}
    let nextNumber = 1;
    let nextAlphaCode = "A".charCodeAt(0);

    // 座標描画
    function drawCoordinates(ctx, canvasWidth, canvasHeight, innerSize) {
      const letters = "ABCDEFGHIJKLMNO".split("");
      ctx.font = "bold 14px sans-serif";
      ctx.fillStyle = "black";

      // 横軸アルファベット
      ctx.textAlign = "center";
      for (let i = 0; i < size; i++) {
        ctx.fillText(letters[i], marginLeft + i * cell, marginTop + innerSize + 15);
      }

      // 縦軸数字
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (let i = 0; i < size; i++) {
        ctx.fillText(size - i, marginLeft - 5, marginTop + i * cell + cell / 2 - 15);
      }
    }

    // 星描画
    function drawStars(ctx) {
      const starCoords = [
        { x: 7,  y: 7 },   // 天元
        { x: 3,  y: 3 },   // D4
        { x: 3,  y: 11 },  // D12
        { x: 11, y: 3 },   // L4
        { x: 11, y: 11 }   // L12
      ];

      ctx.fillStyle = "black";
      starCoords.forEach(pos => {
        const cx = marginLeft + pos.x * cell;
        const cy = marginTop + (size - 1 - pos.y) * cell;
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // コメント描画
    function drawComments(ctx, canvasWidth, canvasHeight) {
      const topText = document.getElementById("commentTop").value;
      const bottomText = document.getElementById("commentBottom").value;

      ctx.font = "16px sans-serif";
      ctx.fillStyle = "black";

      if (topText.trim() !== "") {
        ctx.textAlign = "center";
        const lines = topText.split("\n");
        lines.forEach((line, i) => {
          ctx.fillText(line, canvasWidth / 2, 25 + i * 20);
        });
      }

      if (bottomText.trim() !== "") {
        ctx.textAlign = "left";
        const lines = bottomText.split("\n");
        const startY = marginTop + (size * cell) + 5;
        lines.forEach((line, i) => {
          ctx.fillText(line, marginLeft, startY + i * 20);
        });
      }
    }

    // --- 盤描画 ---
    function renderBoard() {
      const innerSize = (size - 1) * cell;
      const boardSize = size * cell;
      const canvasWidth  = marginLeft + boardSize + marginRight;
      const canvasHeight = marginTop + boardSize + marginBottom;

      const canvas = document.createElement("canvas");
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#F9EBCF";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      for (let i = 1; i < size - 1; i++) {
        const x = marginLeft + i * cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, marginTop);
        ctx.lineTo(x, marginTop + innerSize);
        ctx.stroke();
      }
      for (let i = 1; i < size - 1; i++) {
        const y = marginTop + i * cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(marginLeft, y);
        ctx.lineTo(marginLeft + innerSize, y);
        ctx.stroke();
      }

      ctx.lineWidth = 2;
      ctx.strokeRect(marginLeft + 0.5, marginTop + 0.5, innerSize, innerSize);

      drawCoordinates(ctx, canvas.width, canvas.height, innerSize);
      drawStars(ctx);

      moves.forEach((m) => {
        const cx = marginLeft + m.x * cell;
        const cy = marginTop + (size - 1 - m.y) * cell;

        ctx.beginPath();
        ctx.arc(cx, cy, 12, 0, Math.PI * 2);
        ctx.fillStyle = m.color === "black" ? "black" : "white";
        ctx.fill();
        ctx.stroke();

        if (m.number !== null) {
          ctx.fillStyle = m.color === "black" ? "white" : "black";
          ctx.font = "bold 12px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(m.number, cx, cy);
        }
      });

      // ★ 修正: ラベル描画（背景で線を消す）
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      labels.forEach(l => {
        const cx = marginLeft + l.x * cell;
        const cy = marginTop + (size - 1 - l.y) * cell;

        ctx.fillStyle = "#F9EBCF";
        ctx.fillRect(cx - cell/2 + 1, cy - cell/2 + 1, cell - 2, cell - 2);

        ctx.fillStyle = "red";
        ctx.fillText(l.text, cx, cy);
      });

      drawComments(ctx, canvas.width, canvas.height);

      canvas.oncontextmenu = e => e.preventDefault();
      canvas.addEventListener("click", e => handleClick(e, "left"));
      canvas.addEventListener("contextmenu", e => handleClick(e, "right"));

      const container = document.getElementById("board");
      container.innerHTML = "";
      container.appendChild(canvas);

      const letters2 = "abcdefghijklmno";
      const kifu = moves
        .filter(m => m.number !== null)
        .sort((a, b) => a.number - b.number)
        .map(m => letters2[m.x] + (m.y + 1))
        .join("");
      const textarea = document.getElementById("kifuInput");
      if (textarea && textarea.value !== kifu) {
        textarea.value = kifu;
      }
    }

   // --- クリック処理 ---
function handleClick(e, button) {
  const rect = e.target.getBoundingClientRect();
  const x = Math.round((e.clientX - rect.left - marginLeft) / cell);
  const y = size - 1 - Math.round((e.clientY - rect.top - marginTop) / cell);

  if (x < 0 || y < 0 || x >= size || y >= size) return;

  // ★ 追加: ラベル入力
  if (document.getElementById("inputNumber").checked) {
    labels.push({ x, y, text: String(nextNumber++) });
    renderBoard();
    return;
  }
  if (document.getElementById("inputAlpha").checked) {
    labels.push({ x, y, text: String.fromCharCode(nextAlphaCode++) });
    renderBoard();
    return;
  }

  if (freeMode) {
    // ★ チェックボックス優先
    if (placeBlack.checked) {
      if (boardState[y][x] === "black") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "black";
        moves.push({ x, y, color: "black", number: null });
      }
      renderBoard();
      return;
    }
    if (placeWhite.checked) {
      if (boardState[y][x] === "white") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "white";
        moves.push({ x, y, color: "white", number: null });
      }
      renderBoard();
      return;
    }

    // ★ チェックなし → 従来の自由配置処理
    if (button === "left") {
      if (boardState[y][x] === "black") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "black";
        moves.push({ x, y, color: "black", number: null });
      }
    } else if (button === "right") {
      if (boardState[y][x] === "white") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "white";
        moves.push({ x, y, color: "white", number: null });
      }
    }

  } else {
    // --- 通常モード ---
    if (button === "left") {
      if (boardState[y][x]) return;
      const color = blackTurn ? "black" : "white";
      const moveNumber = moves.filter(m => m.number !== null).length + 1;
      boardState[y][x] = color;
      moves.push({ x, y, color, number: moveNumber });
      redoStack = [];  // ★ 新規着手で未来を消す
      blackTurn = !blackTurn;
    } else if (button === "right") {
      const last = moves.pop();
      if (last) {
        boardState[last.y][last.x] = null;
        if (last.number !== null) {
          blackTurn = (last.color === "black");
        }
      }
    }
  }

  renderBoard();
}


    // ★ 追加: 削除ボタン
    document.getElementById("clearLabels").addEventListener("click", () => {
      labels = [];
      nextNumber = 1;
      nextAlphaCode = "A".charCodeAt(0);
      renderBoard();
    });

    // --- PNG保存 ---
    document.getElementById("saveBoardPng").addEventListener("click", () => {
      const tempCanvas = renderBoardForGif(moves); // 全着手
      const link = document.createElement("a");
      link.href = tempCanvas.toDataURL("image/png");
      link.download = "board.png";
      link.click();
    });

    // --- GIF保存 ---
    document.getElementById("saveGifBtn").addEventListener("click", () => {
      const intervalSec   = parseFloat(document.getElementById("gifInterval").value) || 0.5;
      const firstDelaySec = parseFloat(document.getElementById("gifFirstDelay").value) || intervalSec;
      const lastDelaySec  = parseFloat(document.getElementById("gifLastDelay").value) || intervalSec;
      const startMove     = parseInt(document.getElementById("gifStartMove").value) || 1;

      const interval   = intervalSec * 1000;
      const firstDelay = firstDelaySec * 1000;
      const lastDelay  = lastDelaySec * 1000;

      const gif = new GIF({ workers: 2, quality: 10 });

      const baseMoves = moves.filter(m => m.number === null || m.number < startMove);
      gif.addFrame(renderBoardForGif(baseMoves), { delay: firstDelay });

      for (let i = startMove; i <= moves.length; i++) {
        const tempMoves = moves.filter(m => m.number === null || m.number <= i);
        gif.addFrame(renderBoardForGif(tempMoves), { delay: (i === moves.length ? lastDelay : interval) });
      }

      gif.on("finished", blob => {
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "board.gif";
        link.click();
      });
      gif.render();
    });

    // --- GIF/PNG共通描画 ---
    function renderBoardForGif(movesSubset) {
      const innerSize = (size - 1) * cell;
      const boardSize = size * cell;
      const canvasWidth  = marginLeft + boardSize + marginRight;
      const canvasHeight = marginTop + boardSize + marginBottom;

      const canvas = document.createElement("canvas");
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#F9EBCF";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      for (let i = 1; i < size - 1; i++) {
        const x = marginLeft + i * cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, marginTop);
        ctx.lineTo(x, marginTop + innerSize);
        ctx.stroke();
      }
      for (let i = 1; i < size - 1; i++) {
        const y = marginTop + i * cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(marginLeft, y);
        ctx.lineTo(marginLeft + innerSize, y);
        ctx.stroke();
      }

      ctx.lineWidth = 2;
      ctx.strokeRect(marginLeft + 0.5, marginTop + 0.5, innerSize, innerSize);

      drawCoordinates(ctx, canvas.width, canvas.height, innerSize);
      drawStars(ctx);

      movesSubset.forEach(m => {
        const cx = marginLeft + m.x * cell;
        const cy = marginTop + (size - 1 - m.y) * cell;

        ctx.beginPath();
        ctx.arc(cx, cy, 12, 0, Math.PI * 2);
        ctx.fillStyle = m.color === "black" ? "black" : "white";
        ctx.fill();
        ctx.stroke();

        if (m.number !== null) {
          ctx.fillStyle = m.color === "black" ? "white" : "black";
          ctx.font = "bold 12px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(m.number, cx, cy);
        }
      });

      // ラベルとコメントも描画
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      labels.forEach(l => {
        const cx = marginLeft + l.x * cell;
        const cy = marginTop + (size - 1 - l.y) * cell;
        ctx.fillStyle = "#F9EBCF";
                ctx.fillRect(cx - cell/2 + 1, cy - cell/2 + 1, cell - 2, cell - 2);
        ctx.fillStyle = "red";
        ctx.fillText(l.text, cx, cy);
      });

      drawComments(ctx, canvas.width, canvas.height);
      return canvas;
    }  // ← ここで関数を閉じる

    // === URLパラメータから盤面を再現 & UIイベント初期化 ===
    window.addEventListener("load", () => {
      const params = new URLSearchParams(window.location.search);

      // --- 通常モード棋譜 ---
const kifu = params.get("kifu");
if (kifu) {
  const letters = "abcdefghijklmno";
  const positions = kifu.split(",");
  positions.forEach((pos, idx) => {
    const x = letters.indexOf(pos[0]);
    const y = parseInt(pos.slice(1), 10) - 1;
    if (x >= 0 && y >= 0) {
      const color = (idx % 2 === 0) ? "black" : "white"; // idxで交互に
      const moveNumber = idx + 1; // move番号もidxベースで連番
      moves.push({ x, y, color, number: moveNumber });
      boardState[y][x] = color;
    }
  });
}


      // --- 自由配置 ---
      const stones = params.get("stones");
      if (stones) {
        const letters = "abcdefghijklmno";
        stones.split(",").forEach(str => {
          const coord = str.slice(0, -1);
          const colMark = str.slice(-1).toLowerCase();
          const x = letters.indexOf(coord[0]);
          const y = parseInt(coord.slice(1), 10) - 1;
          if (x >= 0 && y >= 0 && (colMark === "b" || colMark === "w")) {
            const color = (colMark === "b") ? "black" : "white";
            moves.push({ x, y, color, number: null });
            boardState[y][x] = color;
          }
        });
      }

      // --- ラベル ---
      const labelsParam = params.get("labels");
      if (labelsParam) {
        const letters = "abcdefghijklmno";
        labelsParam.split(",").forEach(str => {
          const [coord, text] = str.split(":");
          const x = letters.indexOf(coord[0]);
          const y = parseInt(coord.slice(1), 10) - 1;
          if (x >= 0 && y >= 0 && text) {
            labels.push({ x, y, text });
          }
        });
      }

      // --- コメント ---
      const top = params.get("top");
      const bottom = params.get("bottom");
      if (top) document.getElementById("commentTop").value = top;
      if (bottom) document.getElementById("commentBottom").value = bottom;

   
      // 初期描画
      renderBoard();
    });

    // リンク生成ボタン
    document.getElementById("generateLinkBtn").addEventListener("click", () => {
      const letters = "abcdefghijklmno";
      let url = window.location.origin + window.location.pathname;
      let queryParts = [];

    // --- 通常モード棋譜 ---
const numberedMoves = moves.filter(m => m.number !== null);
if (numberedMoves.length > 0) {
  const kifu = numberedMoves
    .sort((a, b) => a.number - b.number)
    .map(m => letters[m.x] + (m.y + 1))
    .join(",");   // ★ ここを修正（区切り文字を入れる）
  queryParts.push("kifu=" + encodeURIComponent(kifu));
}
      // --- 自由配置 ---
      const freeStones = moves
        .filter(m => m.number === null)
        .map(m => letters[m.x] + (m.y + 1) + (m.color === "black" ? "b" : "w"))
        .join(",");
      if (freeStones) {
        queryParts.push("stones=" + encodeURIComponent(freeStones));
      }

      // --- ラベル ---
      const labelStr = labels
        .map(l => letters[l.x] + (l.y + 1) + ":" + l.text)
        .join(",");
      if (labelStr) {
        queryParts.push("labels=" + encodeURIComponent(labelStr));
      }

      // --- コメント ---
      const topText = document.getElementById("commentTop").value.trim();
      const bottomText = document.getElementById("commentBottom").value.trim();
      if (topText) queryParts.push("top=" + encodeURIComponent(topText));
      if (bottomText) queryParts.push("bottom=" + encodeURIComponent(bottomText));

      if (queryParts.length > 0) {
        url += "?" + queryParts.join("&");
      }

      // 表示用
      const linkBox = document.getElementById("generatedLink");
      linkBox.value = url;

      // コピー
      navigator.clipboard.writeText(url)
        .then(() => alert("リンクをコピーしました！"))
        .catch(err => {
          console.error("コピー失敗:", err);
          alert("コピーに失敗しました");
        });
    });

 let redoStack = [];  // 戻した手を保持するスタック

// 一手戻す
function undoMove() {
  if (freeMode) return; // 自由配置では無効
  const last = moves.pop();
  if (last) {
    redoStack.push(last);
    boardState[last.y][last.x] = null;
    renderBoard();
  }
}

// 一手進める
function redoMove() {
  if (freeMode) return;
  const move = redoStack.pop();
  if (move) {
    moves.push(move);
    boardState[move.y][move.x] = move.color;
    renderBoard();
  }
}

// 全て戻す
function undoAll() {
  if (freeMode) return;
  while (moves.length > 0) {
    const last = moves.pop();
    redoStack.push(last);
    boardState[last.y][last.x] = null;
  }
  renderBoard();
}

// 全て進める
function redoAll() {
  if (freeMode) return;
  while (redoStack.length > 0) {
    const move = redoStack.pop();
    moves.push(move);
    boardState[move.y][move.x] = move.color;
  }
  renderBoard();
}




document.getElementById("undoBtn").addEventListener("click", undoMove);
document.getElementById("redoBtn").addEventListener("click", redoMove);
document.getElementById("undoAllBtn").addEventListener("click", undoAll);
document.getElementById("redoAllBtn").addEventListener("click", redoAll);

const placeBlack = document.getElementById("placeBlack");
const placeWhite = document.getElementById("placeWhite");

// チェック排他制御
placeBlack.addEventListener("change", () => {
  if (placeBlack.checked) {
    placeWhite.checked = false;
  }
});
placeWhite.addEventListener("change", () => {
  if (placeWhite.checked) {
    placeBlack.checked = false;
  }
});

// 自由配置モード切り替え時に表示・非表示
const toggleBtn = document.getElementById("toggleModeBtn");
toggleBtn.addEventListener("click", () => {
  freeMode = !freeMode;
  toggleBtn.textContent = freeMode ? "通常モードに切替" : "自由配置モードに切替";
  document.getElementById("freeModeControls").style.display = freeMode ? "block" : "none";
  if (!freeMode) {
    placeBlack.checked = false;
    placeWhite.checked = false;
  }
});



  </script>  
</body>
</html>

