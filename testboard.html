<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>テスト環境連珠盤</title>
  <style>
    body { font-family: sans-serif; }
    #controls { margin: 10px 0; }
    canvas { border: 1px solid #ccc; }
    label { margin-right: 10px; }

    #gifSettingsPopup {
  display: none;
  position: fixed;
  top: 20%;
  left: 30%;
  width: 40%;
  background: #fff;
  border: 2px solid #333;
  padding: 15px;
  z-index: 1000;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

  </style>
</head>
<body>
  〇使い方<br>
  自由に置けるだけの盤です。私の<a href="https://www.youtube.com/channel/UCfbgN9hrrh9fmFKs8gxln5g">動画編集用</a>に作成しました。特殊な機能はありません。大会集計ツールは<a href="index.html">こちら</a><br>
  通常モードでは黒白交互に石を置けます。<br>
  左クリック→着手<br>
  右クリック→一手戻す<br>
  自由配置モードでは、<br>
  左クリック→黒石<br>
  右クリック→白石<br>
  二回クリックすると石が消えます。
  <div id="controls">
    <button id="toggleModeBtn">自由配置モードに切替</button>
    <button id="saveBoardPng">PNG保存</button>
    <!-- ★ GIF保存詳細設定ポップアップ -->
<button id="gifSettingsBtn">GIF保存詳細設定</button>
<div id="gifSettingsPopup">
  <h3>GIF保存詳細設定</h3>

  <label>開始手数: <input type="number" id="gifStartMove" value="1" min="1"></label><br>
  <label>更新間隔(秒): <input type="number" id="gifInterval" value="0.5" step="0.1"></label><br>
  <label>最初フレーム静止(秒): <input type="number" id="gifFirstDelay" value="1" step="0.1"></label><br>
  <label>最終フレーム静止(秒): <input type="number" id="gifLastDelay" value="2" step="0.1"></label><br><hr>

  <label>・下記情報を最終フレームのみ反映</label><br>
  <label><input type="checkbox" id="finalNumber"> 数字</label><br>
  <label><input type="checkbox" id="finalAlpha"> アルファベット</label><br><hr>

  上段コメント(最終フレーム):<br>
  <textarea id="finalCommentTop" rows="2" style="width:95%;"></textarea><br>
  下段コメント(最終フレーム):<br>
  <textarea id="finalCommentBottom" rows="2" style="width:95%;"></textarea><br><br>


  <button id="closeGifSettings">閉じる</button>
</div>
<button id="previewGifBtn">GIF保存</button>
<!-- 最終フレームプレビューポップアップ -->
<!-- GIF全体プレビューポップアップ -->
<div id="gifPreviewPopup" style="display:none;
  position:fixed; top:10%; left:20%; width:60%;
  background:#fff; border:2px solid #333; padding:15px;
  z-index:2000; box-shadow:0 0 15px rgba(0,0,0,0.5); text-align:center;">
  <h3>GIFプレビュー</h3>
  <div id="gifPreviewContent"></div>
  <br>
  <button id="saveGifBtn">保存</button>
  <button id="closeGifPreview">閉じる</button>
</div>


    <br>
    <!-- ★ 追加部分 -->
    <label><input type="checkbox" id="inputNumber"> 数字を入力</label>
    <label><input type="checkbox" id="inputAlpha"> アルファベットを入力</label>
    <button id="clearLabels">入力文字削除</button>
    <br><button id="generateLinkBtn">リンク生成＆コピー</button>
    <br>
    <input type="text" id="generatedLink" readonly style="width:60%;">
  </div>
  <br>
  <div id="board"></div>
  <div id="controls">
  <button id="undoAllBtn">全て戻す</button>
  <button id="undoBtn">一手戻す</button>
  <button id="redoBtn">一手進める</button>
  <button id="redoAllBtn">全て進める</button>
</div>
<div id="freeModeControls" style="display:none; margin-top:5px;">
  <label><input type="checkbox" id="placeBlack"> 黒石配置モード</label>
  <label><input type="checkbox" id="placeWhite"> 白石配置モード</label>
</div>

  <div style="margin-top:10px; text-align:left;">
    <textarea id="kifuInput" rows="3"
              style="width:40%; font-family:monospace;"
              placeholder="ここに棋譜を入力 (例: h8i9h10...)"></textarea>
  </div>

  <!-- コメント欄 -->
  <div style="margin-top:10px;">
    上段コメント:画像保存時、盤の上側に入力したテキストが表示されます。<br>
    <textarea id="commentTop" rows="2" style="width:60%;"></textarea>
  </div>
  <div style="margin-top:10px;">
    下段コメント:画像保存時、盤の下側に入力したテキストが表示されます。<br>
    <textarea id="commentBottom" rows="2" style="width:60%;"></textarea>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>

  <script>
    const size = 15;
    const cell = 30;
    const marginLeft = 25;
    const marginRight = 20;
    const marginTop = 60;
    const marginBottom = 60;

    let freeMode = false;
    let blackTurn = true;
    let moves = []; // {x, y, color, number}
    let boardState = Array.from({ length: size }, () => Array(size).fill(null));

    // ★ 追加: ラベル管理
    let labels = []; // {x,y,text}
    let nextNumber = 1;
    let nextAlphaCode = "A".charCodeAt(0);

    // 座標描画
    function drawCoordinates(ctx, canvasWidth, canvasHeight, innerSize) {
      const letters = "ABCDEFGHIJKLMNO".split("");
      ctx.font = "bold 14px sans-serif";
      ctx.fillStyle = "black";

      // 横軸アルファベット
      ctx.textAlign = "center";
      for (let i = 0; i < size; i++) {
        ctx.fillText(letters[i], marginLeft + i * cell, marginTop + innerSize + 15);
      }

      // 縦軸数字
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (let i = 0; i < size; i++) {
        ctx.fillText(size - i, marginLeft - 5, marginTop + i * cell + cell / 2 - 15);
      }
    }

    // 星描画
    function drawStars(ctx) {
      const starCoords = [
        { x: 7,  y: 7 },   // 天元
        { x: 3,  y: 3 },   // D4
        { x: 3,  y: 11 },  // D12
        { x: 11, y: 3 },   // L4
        { x: 11, y: 11 }   // L12
      ];

      ctx.fillStyle = "black";
      starCoords.forEach(pos => {
        const cx = marginLeft + pos.x * cell;
        const cy = marginTop + (size - 1 - pos.y) * cell;
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // コメント描画
    function drawComments(ctx, canvasWidth, canvasHeight) {
      const topText = document.getElementById("commentTop").value;
      const bottomText = document.getElementById("commentBottom").value;

      ctx.font = "16px sans-serif";
      ctx.fillStyle = "black";

      if (topText.trim() !== "") {
        ctx.textAlign = "center";
        const lines = topText.split("\n");
        lines.forEach((line, i) => {
          ctx.fillText(line, canvasWidth / 2, 25 + i * 20);
        });
      }

      if (bottomText.trim() !== "") {
        ctx.textAlign = "left";
        const lines = bottomText.split("\n");
        const startY = marginTop + (size * cell) + 5;
        lines.forEach((line, i) => {
          ctx.fillText(line, marginLeft, startY + i * 20);
        });
      }
    }

    // --- 盤描画 ---
    function renderBoard() {
      const innerSize = (size - 1) * cell;
      const boardSize = size * cell;
      const canvasWidth  = marginLeft + boardSize + marginRight;
      const canvasHeight = marginTop + boardSize + marginBottom;

      const canvas = document.createElement("canvas");
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#F9EBCF";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      for (let i = 1; i < size - 1; i++) {
        const x = marginLeft + i * cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, marginTop);
        ctx.lineTo(x, marginTop + innerSize);
        ctx.stroke();
      }
      for (let i = 1; i < size - 1; i++) {
        const y = marginTop + i * cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(marginLeft, y);
        ctx.lineTo(marginLeft + innerSize, y);
        ctx.stroke();
      }

      ctx.lineWidth = 2;
      ctx.strokeRect(marginLeft + 0.5, marginTop + 0.5, innerSize, innerSize);

      drawCoordinates(ctx, canvas.width, canvas.height, innerSize);
      drawStars(ctx);

      moves.forEach((m) => {
        const cx = marginLeft + m.x * cell;
        const cy = marginTop + (size - 1 - m.y) * cell;

        ctx.beginPath();
        ctx.arc(cx, cy, 12, 0, Math.PI * 2);
        ctx.fillStyle = m.color === "black" ? "black" : "white";
        ctx.fill();
        ctx.stroke();

        if (m.number !== null) {
          ctx.fillStyle = m.color === "black" ? "white" : "black";
          ctx.font = "bold 12px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(m.number, cx, cy);
        }
      });

      // ★ 修正: ラベル描画（背景で線を消す）
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      labels.forEach(l => {
        const cx = marginLeft + l.x * cell;
        const cy = marginTop + (size - 1 - l.y) * cell;

        ctx.fillStyle = "#F9EBCF";
        ctx.fillRect(cx - cell/2 + 1, cy - cell/2 + 1, cell - 2, cell - 2);

        ctx.fillStyle = "red";
        ctx.fillText(l.text, cx, cy);
      });

      drawComments(ctx, canvas.width, canvas.height);

      canvas.oncontextmenu = e => e.preventDefault();
      canvas.addEventListener("click", e => handleClick(e, "left"));
      canvas.addEventListener("contextmenu", e => handleClick(e, "right"));

      const container = document.getElementById("board");
      container.innerHTML = "";
      container.appendChild(canvas);

      const letters2 = "abcdefghijklmno";
      const kifu = moves
        .filter(m => m.number !== null)
        .sort((a, b) => a.number - b.number)
        .map(m => letters2[m.x] + (m.y + 1))
        .join("");
      const textarea = document.getElementById("kifuInput");
      if (textarea && textarea.value !== kifu) {
        textarea.value = kifu;
      }
    }

    // --- クリック処理 ---
function handleClick(e, button) {
  const rect = e.target.getBoundingClientRect();
  const x = Math.round((e.clientX - rect.left - marginLeft) / cell);
  const y = size - 1 - Math.round((e.clientY - rect.top - marginTop) / cell);

  if (x < 0 || y < 0 || x >= size || y >= size) return;

  // ★ ラベル入力モード
  if (document.getElementById("inputNumber").checked) {
    labels.push({ x, y, text: String(nextNumber++) });
    renderBoard();
    return;
  }
  if (document.getElementById("inputAlpha").checked) {
    labels.push({ x, y, text: String.fromCharCode(nextAlphaCode++) });
    renderBoard();
    return;
  }

  // --- 自由配置モード ---
  if (freeMode) {
    // 黒石配置モード優先
    if (placeBlack.checked) {
      if (boardState[y][x] === "black") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "black";
        moves.push({ x, y, color: "black", number: null });
      }
      renderBoard();
      return;
    }

    // 白石配置モード優先
    if (placeWhite.checked) {
      if (boardState[y][x] === "white") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "white";
        moves.push({ x, y, color: "white", number: null });
      }
      renderBoard();
      return;
    }

    // チェックなし → 左クリック=黒 / 右クリック=白
    if (button === "left") {
      if (boardState[y][x] === "black") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "black";
        moves.push({ x, y, color: "black", number: null });
      }
    } else if (button === "right") {
      if (boardState[y][x] === "white") {
        boardState[y][x] = null;
        moves = moves.filter(m => !(m.x === x && m.y === y));
      } else {
        boardState[y][x] = "white";
        moves.push({ x, y, color: "white", number: null });
      }
    }
  }

  // --- 通常モード ---
  else {
    if (button === "left") {
      if (boardState[y][x]) return; // すでに石あり
      const color = blackTurn ? "black" : "white";
      const moveNumber = moves.filter(m => m.number !== null).length + 1;
      boardState[y][x] = color;
      moves.push({ x, y, color, number: moveNumber });
      redoStack = []; // 新規着手で未来を消す
      blackTurn = !blackTurn;
    } else if (button === "right") {
      const last = moves.pop();
      if (last) {
        boardState[last.y][last.x] = null;
        if (last.number !== null) {
          blackTurn = (last.color === "black");
        }
        redoStack.push(last); // 戻した手を redoStack に入れる
      }
    }
  }

  renderBoard();
}

    // ★ 追加: 削除ボタン
    document.getElementById("clearLabels").addEventListener("click", () => {
      labels = [];
      nextNumber = 1;
      nextAlphaCode = "A".charCodeAt(0);
      renderBoard();
    });

    // --- PNG保存 ---
    document.getElementById("saveBoardPng").addEventListener("click", () => {
      const tempCanvas = renderBoardForGif(moves); // 全着手
      const link = document.createElement("a");
      link.href = tempCanvas.toDataURL("image/png");
      link.download = "board.png";
      link.click();
    });

// --- GIF保存 ---
document.getElementById("saveGifBtn").addEventListener("click", () => {
  const intervalSec   = parseFloat(document.getElementById("gifInterval").value) || 0.5;
  const firstDelaySec = parseFloat(document.getElementById("gifFirstDelay").value) || intervalSec;
  const lastDelaySec  = parseFloat(document.getElementById("gifLastDelay").value) || intervalSec;
  const startMove     = parseInt(document.getElementById("gifStartMove").value) || 1;

  const finalNumber = document.getElementById("finalNumber").checked;
  const finalAlpha = document.getElementById("finalAlpha").checked;
  const finalCommentTop = document.getElementById("finalCommentTop").value;
  const finalCommentBottom = document.getElementById("finalCommentBottom").value;

  const interval   = intervalSec * 1000;
  const firstDelay = firstDelaySec * 1000;
  const lastDelay  = lastDelaySec * 1000;

  const gif = new GIF({ workers: 2, quality: 10 });

  // --- 1フレーム目（開始局面）
  const baseMoves = moves.filter(m => m.number === null || m.number < startMove);
  gif.addFrame(renderBoardForGif(baseMoves, { frameType:"normal" }), { delay: firstDelay });

  // --- 通常モードの最後の着手番号を取得
  const lastMoveNumber = Math.max(0, ...moves.filter(m => m.number !== null).map(m => m.number));

  // --- メインループ
  for (let i = startMove; i <= lastMoveNumber; i++) {
    const tempMoves = moves.filter(m => m.number === null || (m.number !== null && m.number <= i));
    const isFinal = (i === lastMoveNumber);

    let extra = { frameType: isFinal ? "final" : "normal" };
    if (isFinal) {
      extra.finalNumber = finalNumber;
      extra.finalAlpha = finalAlpha;
      extra.finalTop = finalCommentTop;
      extra.finalBottom = finalCommentBottom;
    }

    gif.addFrame(renderBoardForGif(tempMoves, extra), { delay: (isFinal ? lastDelay : interval) });
  }

  gif.on("finished", blob => {
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "board.gif";
    link.click();
  });

  gif.render();
});





 // --- GIF/PNG共通描画 ---
function renderBoardForGif(movesSubset, extra = {}) {
  const innerSize = (size - 1) * cell;
  const boardSize = size * cell;
  const canvasWidth  = marginLeft + boardSize + marginRight;
  const canvasHeight = marginTop + boardSize + marginBottom;

  const canvas = document.createElement("canvas");
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "#F9EBCF";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  for (let i = 1; i < size - 1; i++) {
    const x = marginLeft + i * cell + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, marginTop);
    ctx.lineTo(x, marginTop + innerSize);
    ctx.stroke();
  }
  for (let i = 1; i < size - 1; i++) {
    const y = marginTop + i * cell + 0.5;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + innerSize, y);
    ctx.stroke();
  }

  ctx.lineWidth = 2;
  ctx.strokeRect(marginLeft + 0.5, marginTop + 0.5, innerSize, innerSize);

  drawCoordinates(ctx, canvas.width, canvas.height, innerSize);
  drawStars(ctx);

  // 石の描画
  movesSubset.forEach(m => {
    const cx = marginLeft + m.x * cell;
    const cy = marginTop + (size - 1 - m.y) * cell;

    ctx.beginPath();
    ctx.arc(cx, cy, 12, 0, Math.PI * 2);
    ctx.fillStyle = m.color === "black" ? "black" : "white";
    ctx.fill();
    ctx.stroke();

    if (m.number !== null) {
      ctx.fillStyle = m.color === "black" ? "white" : "black";
      ctx.font = "bold 12px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(m.number, cx, cy);
    }
  });

  // --- ラベル描画 ---
  ctx.font = "bold 14px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  if (extra.frameType === "final") {
    // ★ 最終フレーム → チェックボックスに応じて数字/アルファを選択描画
    labels.forEach(l => {
      const isNumber = !isNaN(l.text);
      const isAlpha = /^[A-Z]$/.test(l.text);

      if ((isNumber && !extra.finalNumber) || (isAlpha && !extra.finalAlpha)) return;

      const cx = marginLeft + l.x * cell;
      const cy = marginTop + (size - 1 - l.y) * cell;

      // 背景を塗りつぶしてから文字描画
      ctx.fillStyle = "#F9EBCF";
      ctx.fillRect(cx - cell/2 + 1, cy - cell/2 + 1, cell - 2, cell - 2);

      ctx.fillStyle = "red";
      ctx.fillText(l.text, cx, cy);
    });
  } else {
    // ★ 通常フレーム → 数字/アルファ以外のみ描画
    labels.forEach(l => {
      const isNumber = !isNaN(l.text);
      const isAlpha = /^[A-Z]$/.test(l.text);
      if (isNumber || isAlpha) return;

      const cx = marginLeft + l.x * cell;
      const cy = marginTop + (size - 1 - l.y) * cell;

      ctx.fillStyle = "#F9EBCF";
      ctx.fillRect(cx - cell/2 + 1, cy - cell/2 + 1, cell - 2, cell - 2);

      ctx.fillStyle = "red";
      ctx.fillText(l.text, cx, cy);
    });
  }

  // 通常コメント
  drawComments(ctx, canvas.width, canvas.height);

  // ★ 最終フレーム専用コメント
  if (extra.frameType === "final") {
    ctx.fillStyle = "black";
    if (extra.finalTop) {
      ctx.font = "18px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(extra.finalTop, canvasWidth / 2, 50);
    }
    if (extra.finalBottom) {
      ctx.font = "18px sans-serif";
      ctx.textAlign = "right";
      ctx.fillText(extra.finalBottom, canvasWidth - marginRight - 10, canvasHeight - 60);
    }
  }

  return canvas;
}



    // === URLパラメータから盤面を再現 & UIイベント初期化 ===
    window.addEventListener("load", () => {
      const params = new URLSearchParams(window.location.search);

      // --- 通常モード棋譜 ---
const kifu = params.get("kifu");
if (kifu) {
  const letters = "abcdefghijklmno";
  const positions = kifu.split(",");
  positions.forEach((pos, idx) => {
    const x = letters.indexOf(pos[0]);
    const y = parseInt(pos.slice(1), 10) - 1;
    if (x >= 0 && y >= 0) {
      const color = (idx % 2 === 0) ? "black" : "white"; // idxで交互に
      const moveNumber = idx + 1; // move番号もidxベースで連番
      moves.push({ x, y, color, number: moveNumber });
      boardState[y][x] = color;
    }
  });
}


      // --- 自由配置 ---
      const stones = params.get("stones");
      if (stones) {
        const letters = "abcdefghijklmno";
        stones.split(",").forEach(str => {
          const coord = str.slice(0, -1);
          const colMark = str.slice(-1).toLowerCase();
          const x = letters.indexOf(coord[0]);
          const y = parseInt(coord.slice(1), 10) - 1;
          if (x >= 0 && y >= 0 && (colMark === "b" || colMark === "w")) {
            const color = (colMark === "b") ? "black" : "white";
            moves.push({ x, y, color, number: null });
            boardState[y][x] = color;
          }
        });
      }

      // --- ラベル ---
      const labelsParam = params.get("labels");
      if (labelsParam) {
        const letters = "abcdefghijklmno";
        labelsParam.split(",").forEach(str => {
          const [coord, text] = str.split(":");
          const x = letters.indexOf(coord[0]);
          const y = parseInt(coord.slice(1), 10) - 1;
          if (x >= 0 && y >= 0 && text) {
            labels.push({ x, y, text });
          }
        });
      }

      // --- コメント ---
      const top = params.get("top");
      const bottom = params.get("bottom");
      if (top) document.getElementById("commentTop").value = top;
      if (bottom) document.getElementById("commentBottom").value = bottom;

    

      // 初期描画
      renderBoard();
    });

    // リンク生成ボタン
    document.getElementById("generateLinkBtn").addEventListener("click", () => {
      const letters = "abcdefghijklmno";
      let url = window.location.origin + window.location.pathname;
      let queryParts = [];

    // --- 通常モード棋譜 ---
const numberedMoves = moves.filter(m => m.number !== null);
if (numberedMoves.length > 0) {
  const kifu = numberedMoves
    .sort((a, b) => a.number - b.number)
    .map(m => letters[m.x] + (m.y + 1))
    .join(",");   // ★ ここを修正（区切り文字を入れる）
  queryParts.push("kifu=" + encodeURIComponent(kifu));
}
      // --- 自由配置 ---
      const freeStones = moves
        .filter(m => m.number === null)
        .map(m => letters[m.x] + (m.y + 1) + (m.color === "black" ? "b" : "w"))
        .join(",");
      if (freeStones) {
        queryParts.push("stones=" + encodeURIComponent(freeStones));
      }

      // --- ラベル ---
      const labelStr = labels
        .map(l => letters[l.x] + (l.y + 1) + ":" + l.text)
        .join(",");
      if (labelStr) {
        queryParts.push("labels=" + encodeURIComponent(labelStr));
      }

      // --- コメント ---
      const topText = document.getElementById("commentTop").value.trim();
      const bottomText = document.getElementById("commentBottom").value.trim();
      if (topText) queryParts.push("top=" + encodeURIComponent(topText));
      if (bottomText) queryParts.push("bottom=" + encodeURIComponent(bottomText));

      if (queryParts.length > 0) {
        url += "?" + queryParts.join("&");
      }

      // 表示用
      const linkBox = document.getElementById("generatedLink");
      linkBox.value = url;

      // コピー
      navigator.clipboard.writeText(url)
        .then(() => alert("リンクをコピーしました！"))
        .catch(err => {
          console.error("コピー失敗:", err);
          alert("コピーに失敗しました");
        });
    });

    document.getElementById("gifSettingsBtn").addEventListener("click", () => {
  document.getElementById("gifSettingsPopup").style.display = "block";
});
document.getElementById("closeGifSettings").addEventListener("click", () => {
  document.getElementById("gifSettingsPopup").style.display = "none";
});

document.getElementById("previewGifBtn").addEventListener("click", () => {
  const intervalSec   = parseFloat(document.getElementById("gifInterval").value) || 0.5;
  const firstDelaySec = parseFloat(document.getElementById("gifFirstDelay").value) || intervalSec;
  const lastDelaySec  = parseFloat(document.getElementById("gifLastDelay").value) || intervalSec;
  const startMove     = parseInt(document.getElementById("gifStartMove").value) || 1;

  const finalNumber = document.getElementById("finalNumber").checked;
  const finalAlpha = document.getElementById("finalAlpha").checked;
  const finalCommentTop = document.getElementById("finalCommentTop").value;
  const finalCommentBottom = document.getElementById("finalCommentBottom").value;

  const interval   = intervalSec * 1000;
  const firstDelay = firstDelaySec * 1000;
  const lastDelay  = lastDelaySec * 1000;

  const gif = new GIF({ workers: 2, quality: 10 });

  // 1フレーム目
  const baseMoves = moves.filter(m => m.number === null || m.number < startMove);
  gif.addFrame(renderBoardForGif(baseMoves, {frameType:"normal"}), { delay: firstDelay });

  // メインループ
  for (let i = startMove; i <= moves.length; i++) {
    const tempMoves = moves.filter(m => m.number === null || m.number <= i);
    const isFinal = (i === moves.length);

    let extra = { frameType: isFinal ? "final" : "normal" };
    if (isFinal) {
      extra.finalNumber = finalNumber;
      extra.finalAlpha = finalAlpha;
      extra.finalTop = finalCommentTop;
      extra.finalBottom = finalCommentBottom;
    }

    gif.addFrame(renderBoardForGif(tempMoves, extra), { delay: (isFinal ? lastDelay : interval) });
  }

  // 完成時にプレビュー表示
  gif.on("finished", blob => {
    const url = URL.createObjectURL(blob);
    const img = document.createElement("img");
    img.src = url;

    const content = document.getElementById("gifPreviewContent");
    content.innerHTML = "";
    content.appendChild(img);

    document.getElementById("gifPreviewPopup").style.display = "block";
  });

  gif.render();
});

// 閉じるボタン
document.getElementById("closeGifPreview").addEventListener("click", () => {
  document.getElementById("gifPreviewPopup").style.display = "none";
});

let redoStack = [];  // 戻した手を保持するスタック

const placeBlack = document.getElementById("placeBlack");
const placeWhite = document.getElementById("placeWhite");

// 一手戻す
function undoMove() {
  if (freeMode) return; // 自由配置では無効
  const last = moves.pop();
  if (last) {
    redoStack.push(last);
    boardState[last.y][last.x] = null;
    renderBoard();
  }
}

// 一手進める
function redoMove() {
  if (freeMode) return;
  const move = redoStack.pop();
  if (move) {
    moves.push(move);
    boardState[move.y][move.x] = move.color;
    renderBoard();
  }
}

// 全て戻す
function undoAll() {
  if (freeMode) return;
  while (moves.length > 0) {
    const last = moves.pop();
    redoStack.push(last);
    boardState[last.y][last.x] = null;
  }
  renderBoard();
}

// 全て進める
function redoAll() {
  if (freeMode) return;
  while (redoStack.length > 0) {
    const move = redoStack.pop();
    moves.push(move);
    boardState[move.y][move.x] = move.color;
  }
  renderBoard();
}

document.getElementById("undoBtn").addEventListener("click", undoMove);
document.getElementById("redoBtn").addEventListener("click", redoMove);
document.getElementById("undoAllBtn").addEventListener("click", undoAll);
document.getElementById("redoAllBtn").addEventListener("click", redoAll);

// チェック排他制御
placeBlack.addEventListener("change", () => {
  if (placeBlack.checked) {
    placeWhite.checked = false;
  }
});
placeWhite.addEventListener("change", () => {
  if (placeWhite.checked) {
    placeBlack.checked = false;
  }
});

// 自由配置モード切替（1か所にまとめる）
const toggleBtn = document.getElementById("toggleModeBtn");
toggleBtn.addEventListener("click", () => {
  freeMode = !freeMode;

  if (!freeMode) {
    // ★ 通常モードに戻るときに確認
    const start = confirm("黒番から打ち始めますか？（キャンセルすると白番開始）");
    blackTurn = start ? true : false;
  }

  // ボタンの表示更新
  toggleBtn.textContent = freeMode ? "通常モードに切替" : "自由配置モードに切替";

  // 自由配置専用UIの表示切替
  document.getElementById("freeModeControls").style.display = freeMode ? "block" : "none";

  // 通常モードに戻るときは配置チェックをクリア
  if (!freeMode) {
    placeBlack.checked = false;
    placeWhite.checked = false;
  }
});





  </script>  
</body>
</html>
