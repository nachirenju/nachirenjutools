
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>연주 토너먼트 집계 · 스왑 분석</title>
<style>
  body { font-family: sans-serif; padding: 1em; }
  input, button { padding: 5px; margin: 5px; }
  table { border-collapse: collapse; margin-top: 10px; width: 900px; }
  th, td { border: 1px solid #ccc; padding: 5px; text-align: center; }
</style>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>

<h1>연주 토너먼트 집계 · 스왑 분석</h1>

<input type="file" id="fileInput" accept=".rif,.xml"><br>

<!-- 사용법 링크 -->
<a href="#" id="showHelp">사용 방법</a>
<a href="#" id="historyLink">업데이트 내역</a>
<br>
<a href="index.html">日本語</a> | 
<a href="en.html">English</a> | 
<a href="kr.html">Korean</a>

<!-- 모달 -->
<div id="helpModal" style="display:none; position:fixed; top:10%; left:10%; width:80%; max-height:80%; overflow:auto; background:white; border:2px solid black; padding:1em; z-index:1000;">
  <h2>사용 방법</h2>
  <p>연주의 토너먼트 집계 도구입니다. <a href="https://x.com/nachirenju">@nachirenju</a>가 호기심으로 지식 없이 제작한 도구라서, 제대로 동작할지는 미지수입니다.<br>
저는 사용하는 데 문제 없었지만, 이 도구 사용으로 어떤 문제가 발생해도 책임지지 않습니다.<br>
문제가 있으면 X 계정으로 연락 주세요.<br>
이 도구와 직접 관련은 없지만 <a href="https://www.youtube.com/channel/UCfbgN9hrrh9fmFKs8gxln5g">유튜브 채널</a>도 운영하고 있으니 응원해 주시면 감사하겠습니다.<br>
이 페이지는 ChatGPT에 의해 번역되었습니다. 부정확한 부분이 있을 수 있습니다. 궁금한 점이 있으시면 문의해 주세요.
</p>

  <h3>〇 기본적인 사용법</h3>
  <ol>
    <li>「파일 선택」 버튼을 눌러 데이터베이스를 불러옵니다. .rif 및 .xml 파일을 읽을 수 있습니다. (데이터베이스는 <a href="https://www.renju.net/">RIF 공식 사이트</a>에서 다운로드 가능)<br>
        ※ RIF 공식 데이터베이스만으로 동작 검증을 했습니다.</li>
    <li>키워드 검색으로 후보를 찾거나, 오른쪽 칸에 토너먼트 ID를 직접 입력합니다. 쉼표로 여러 개 입력 가능</li>
    <li>입력 후 「토너먼트 집계」 버튼을 누르면 기본 데이터가 표시됩니다.</li>
<li>현재 Soosrv-8, Taraguchi-10, Classic, Yamaguchi 이외의 토너먼트에는 미지원입니다.</li>
<li>플레이어 필터링은 입력한 플레이어가 참가한 모든 토너먼트가 리스트업되고, 다른 조건과 함께 적용됩니다.<br>
※ 여러 명 입력 시, 입력한 모든 플레이어가 참가한 토너먼트만 리스트업됩니다. (쉼표 구분)</li>
  </ol>

  <h3>〇 데이터에 대하여</h3>
  <ul>
    <li>N번째 착수자 승리 수는 결착된 대국만 집계합니다. (무승부 제외)</li>
    <li>빈번 기보 리스트에 흑() 이라는 표기가 있는데, 이는 개국에서 흑이 N번째 수를 두었다는 의미입니다. (스왑 이력)<br>
        (예) 흑(1,3): Suzuki Taro, 백: Sato Jiro → Suzuki가 1,3번째 수, Sato가 2,4,5번째 수 착수</li>
  </ul>

  <h3>〇 플레이어별 집계</h3>
  <ul>
    <li>현재 RIF의 name, surname, nativename 중 하나를 입력하면 검색 가능합니다.</li>
    <li>쉼표 구분으로 여러 명 입력을 지원합니다.</li>
    <li>여러 명 입력 시, 해당 플레이어끼리의 대국만 검색됩니다.<br>
        (예: A,B 입력 시 A vs B만 추출. A,B,C 입력 시 AB, AC, BC 조합 추출)</li>
  </ul>

  <h3>〇 스왑 이력 검색</h3>
  <ul>
    <li>해당 플레이어의 스왑 이력 및 몇 번째 수를 착수했는지 목록으로 표시합니다.</li>
    <li>현재 Taraguchi-10의 10문제 표시에는 미지원</li>
  </ul>

  <button id="closeHelp">닫기</button>
</div>

<div id="historyContent" style="display:none; border:1px solid #ccc; padding:10px; margin-top:5px;">
    <button id="closeHistory" style="float:right;">닫기</button>
  〇 업데이트 내역
<li>2025/09/06 토너먼트 집계 영역 클리어 버튼 추가, 검색 후보를 ID 큰 순서로 표시, 숨김 개수 표시</li>
<li>09/06 플레이어 집계에 이미지 저장 버튼 추가</li>
<li>09/06 플레이어 집계에 .xlsx 출력 버튼 추가</li>
<li>09/12 플레이어 집계의 대국 목록에 포석 표기. 3번째 착수일 경우 노란색 표시</li>
<li>09/12 토너먼트 ID 키워드 검색에 플레이어 필터링 추가, 스왑 이력 검색 개선</li>
<li>09/16 빈번 기보 리스트에 스왑 이력 추가, 포석별 빈번 기보 추가, 스왑 이력 검색의 동명이인 처리 수정, 포석 스왑 검색 지원</li>
</div>


<input type="text" id="keyword" placeholder="키워드로 검색">

<label>
  <input type="checkbox" id="matchPartial" checked>
  부분 일치
</label>
<label>
  <input type="checkbox" id="matchStart">
  처음 일치
</label>
<label><input type="radio" name="matchType" value="regex"> 정규 표현식</label>

<div id="suggestions"></div>

<label><input type="checkbox" class="ruleCheckbox" value="24" checked> Soosrv-8</label>
<label><input type="checkbox" class="ruleCheckbox" value="25" checked> Taraguchi-10</label>
<label><input type="checkbox" class="ruleCheckbox" value="1"  checked> Classic</label>
<label><input type="checkbox" class="ruleCheckbox" value="5"  checked> Yamaguchi</label>

<!-- 토너먼트 검색 -->
<label>
  <input type="checkbox" id="enablePlayerFilter"> 플레이어로 필터링
</label>
<input type="text" id="searchPlayerInput" placeholder="플레이어 이름 입력" style="display:none;">
<button id="searchPlayerCandidatesBtn" style="display:none;">해당 플레이어 검색</button>
<div id="searchPlayerCandidates"></div>


<input type="text" id="tournamentId" placeholder="토너먼트 ID 입력">
<button id="analyzeBtn">토너먼트 집계</button>
<button id="clearBtn">집계 영역 초기화</button>

<h2>토너먼트 승패 통계</h2>
<div id="stats"></div>

<h2>최다 스왑 패턴 대국 예시</h2>
<div id="mostSwapExample"></div>

<h2>포석 랭킹 (상위 10개)</h2>
<table id="openingTable">
  <thead><tr><th>순위</th><th>포석 이름</th><th>건수</th></tr></thead>
  <tbody></tbody>
</table>

<h2>5번째 수까지의 빈번 기보 랭킹 (상위 10)</h2>
<div id="top5MovesContainer"></div>

<h2>포석별 승률 (전체 포석)</h2>
<table id="openingWinRateTable">
  <thead><tr><th>포석 이름</th><th>흑 승률</th><th>백 승률</th><th>무승부율</th><th>대국 수</th></tr></thead>
  <tbody></tbody>
</table>

<h2>플레이어별 집계</h2>
<input type="text" id="playerInput" placeholder="플레이어 이름 입력">
<div id="playerCandidates"></div> <!-- 후보 출력 영역 -->

<button id="analyzePlayerBtn">집계</button>
<div id="playerStats"></div>

<h2>검색한 플레이어의 5번째 수 빈번 기보 top10</h2>
<div id="tournamentplayerTop5MovesContainer"></div>

<h2>스왑 이력 검색</h2>
<input type="text" id="swapPlayerInput" placeholder="플레이어 이름 또는 포석 이름 입력">
<button id="searchSwapBtn">검색</button>
<div id="swapResult"></div>

<!-- 모달 배경 -->
<div id="modalOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%;
     background:rgba(0,0,0,0.5); z-index:1500;"></div>

<!-- 팝업 본체 -->
<div id="openingPopup" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
     width:70%; max-width:800px; max-height:80%; overflow:auto;
     background:white; border-radius:10px; padding:20px; box-shadow:0 0 20px rgba(0,0,0,0.5);
     z-index:2000;">
  <button id="closeOpeningPopup" style="float:right;">✖</button>
  
  <!-- ★ 요약 영역 -->
  <div id="openingSummary"></div>
  
  <!-- ★ Top10 랭킹 영역 -->
  <div id="openingTop10"></div>
</div>





<script>
let allGames = [];
let allTournaments = [];
let allPlayers = {};
let playerIndex = {};
let tournamentMap = {};
let tournamentPlayers = {};   // ★グローバルで宣言


// opening固定定義
const openingMap = {
  "1":  { ja: "長星", en: "i1" },
  "2":  { ja: "峡月", en: "i2" },
  "3":  { ja: "恒星", en: "i3" },
  "4":  { ja: "水月", en: "i4" },
  "5":  { ja: "流星", en: "i5" },
  "6":  { ja: "雲月", en: "i6" },
  "7":  { ja: "浦月", en: "i7" },
  "8":  { ja: "嵐月", en: "i8" },
  "9":  { ja: "銀月", en: "i9" },
  "10": { ja: "明星", en: "i10" },
  "11": { ja: "斜月", en: "i11" },
  "12": { ja: "名月", en: "i12" },
  "13": { ja: "彗星", en: "i13" },

  "14": { ja: "寒星", en: "d1" },
  "15": { ja: "渓月", en: "d2" },
  "16": { ja: "疎星", en: "d3" },
  "17": { ja: "花月", en: "d4" },
  "18": { ja: "残月", en: "d5" },
  "19": { ja: "雨月", en: "d6" },
  "20": { ja: "金星", en: "d7" },
  "21": { ja: "松月", en: "d8" },
  "22": { ja: "丘月", en: "d9" },
  "23": { ja: "新月", en: "d10" },
  "24": { ja: "瑞星", en: "d11" },
  "25": { ja: "山月", en: "d12" },
  "26": { ja: "遊星", en: "d13" },

  // 未入力用
  "27": { ja: "棋譜未入力", en: "Game is not typed" }
};


/*
window.addEventListener("DOMContentLoaded", () => {
    // ここに処理を書く
    document.getElementById("tournamentTabBtn").addEventListener("click", () => openTab('tournamentTab'));
    document.getElementById("playerTabBtn").addEventListener("click", () => openTab('playerTab'));

    document.getElementById("searchPlayerBtn").addEventListener("click", () => {
        // プレイヤー検索処理
    });
}); 
*/




// ファイル読み込み
document.getElementById("fileInput").addEventListener("change", function(e){
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(event){
    const text = event.target.result;
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(text, "text/xml");

    // プレイヤー情報の格納部分
// プレイヤー情報の格納部分
allPlayers = {};
playerIndex = {};
const players = xmlDoc.getElementsByTagName("player");

Array.from(players).forEach(p=>{
  const id = p.getAttribute("id");
  const name = (p.getAttribute("name") || "").trim();
  const surname = (p.getAttribute("surname") || "").trim();
  const native_name = (p.getAttribute("native_name") || "").trim();

  allPlayers[id] = {id,name,surname,native_name};

  // 検索用キーを準備
  const lowerName = name.toLowerCase();
  const lowerSurname = surname.toLowerCase();
  const lowerNative = native_name.toLowerCase();
  const fullName = (surname && name) ? (surname + " " + name).toLowerCase() : "";

  [lowerName, lowerSurname, lowerNative, fullName].forEach(key=>{
    if(key){
      if(!playerIndex[key]) playerIndex[key] = [];
      playerIndex[key].push(id);
    }
  });
});


  // 大会情報の格納部分
tournamentMap = {}; // 初期化
const tournaments = xmlDoc.getElementsByTagName("tournament");

Array.from(tournaments).forEach(t => {
  const id = t.getAttribute("id");
  const name = t.getAttribute("name");
  const country = t.getAttribute("country");
  const city = t.getAttribute("city");
  const year = parseInt(t.getAttribute("year"), 10);
  const month = parseInt(t.getAttribute("month"), 10);
  const start = t.getAttribute("start");
  const end = t.getAttribute("end");
  const rule = parseInt(t.getAttribute("rule"), 10);
  const rated = t.getAttribute("rated") === "1";

  tournamentMap[id] = { 
    id, name, country, city, year, month, start, end, rule, rated 
  };
});


// ←ここに allGames を作る
allTournaments = Object.entries(tournamentMap).map(([id, info]) => {
  return {
    id: Number(id),
    name: info.name,
    rule: info.rule,
    year: info.year
  };
});



// 対局情報
const games = xmlDoc.getElementsByTagName("game");
allGames = Array.from(games).map(g => {
  const tid = g.getAttribute("tournament");
  const tInfo = tournamentMap[tid] || {};
  return {
    id: g.getAttribute("id"),
    tournament: tid,
    tournamentName: tInfo.name || `大会ID ${tid}`,
    rule: tInfo.rule || 0,
    bresult: parseFloat(g.getAttribute("bresult")),
    opening: g.getAttribute("opening"),
    black: g.getAttribute("black"),
    white: g.getAttribute("white"),
    swap: g.getAttribute("swap"),
    moves: g.getElementsByTagName("move")[0]?.textContent.trim() || ""
  };
});

// ★ここで大会ごとの参加プレイヤー集合を構築
tournamentPlayers = {};
allGames.forEach(g => {
  if (!tournamentPlayers[g.tournament]) {
    tournamentPlayers[g.tournament] = new Set();
  }
  tournamentPlayers[g.tournament].add(g.black);
  tournamentPlayers[g.tournament].add(g.white);
});

alert(`読み込み完了: ${allGames.length} 対局`);

  };
  reader.readAsText(file);
});

 const showHelp = document.getElementById("showHelp");
  const helpModal = document.getElementById("helpModal");
  const closeHelp = document.getElementById("closeHelp");

  showHelp.addEventListener("click", function(e){
    e.preventDefault();
    helpModal.style.display = "block";
  });

  closeHelp.addEventListener("click", function(){
    helpModal.style.display = "none";
  });

  // 更新履歴リンク
document.getElementById("historyLink").addEventListener("click", (e) => {
  e.preventDefault();
  const c = document.getElementById("historyContent");
  c.style.display = (c.style.display === "none") ? "block" : "none";
});

function analyzeTaraguchi(g){
  const swapRaw = g.swap || "";
  const swapForCalc = swapRaw.replace(/R/g,"+").padEnd(5,"-");

  const blackFinal = allPlayers[g.black] ? allPlayers[g.black].surname + " " + allPlayers[g.black].name : g.black;
  const whiteFinal = allPlayers[g.white] ? allPlayers[g.white].surname + " " + allPlayers[g.white].name : g.white;

  let black = blackFinal, white = whiteFinal;
  const moveOwners = new Array(6);

  for(let i=5;i>=0;i--){
    moveOwners[i] = ((i+1)%2===1)? black : white;
    if(i>0 && swapForCalc[i-1]==='+'){
      [black, white] = [white, black];
    }
  }
  return { moveOwners, swap: swapRaw }; // 表示用には元データを返す
}

// 更新履歴閉じる
document.getElementById("closeHistory").addEventListener("click", () => {
  document.getElementById("historyContent").style.display = "none";
});

function analyzeSoosrv(g) {
  const swapRaw = (g.swap || "--").replace(/R/g, "+").padEnd(2, "-");
  const swapCount = (swapRaw.match(/\+/g) || []).length;

  const blackFinal = allPlayers[g.black]
    ? allPlayers[g.black].surname + " " + allPlayers[g.black].name
    : g.black;
  const whiteFinal = allPlayers[g.white]
    ? allPlayers[g.white].surname + " " + allPlayers[g.white].name
    : g.white;

  // 初期状態を決定
  let black = blackFinal;
  let white = whiteFinal;
  if (swapCount % 2 === 1) [black, white] = [white, black];

  const moveOwners = [];

  // 1〜3手目: 初期黒
  moveOwners.push(black, black, black);

  // 1回目 swap（3手目終了後）
  if (swapRaw[0] === "+") [black, white] = [white, black];

  // 4手目担当
  moveOwners.push(white);

  // 2回目 swap（4手目終了後）
  if (swapRaw[1] === "+") [black, white] = [white, black];

  // 5手目担当
  moveOwners.push(blackFinal);

  // 手番を分ける
  const blackMoves = [];
  const whiteMoves = [];
  moveOwners.forEach((player, idx) => {
    if (player === blackFinal) blackMoves.push(idx + 1);
    else if (player === whiteFinal) whiteMoves.push(idx + 1);
  });

  return { moveOwners, blackMoves, whiteMoves, swap: swapRaw };
}

function analyzeRIF(g) {
  const swapRaw = (g.swap || "-").replace(/R/g, "+"); // Rを+に置換して扱う

  const blackFinal = allPlayers[g.black]
    ? allPlayers[g.black].surname + " " + allPlayers[g.black].name
    : g.black;
  const whiteFinal = allPlayers[g.white]
    ? allPlayers[g.white].surname + " " + allPlayers[g.white].name
    : g.white;

  const moveOwners = [];

  if (swapRaw === "-") {
    // スワップなし
    moveOwners.push(blackFinal, blackFinal, blackFinal, whiteFinal, blackFinal);
  } else {
    // スワップあり
    moveOwners.push(whiteFinal, whiteFinal, whiteFinal, whiteFinal, blackFinal);
  }

  // 手番を分ける
  const blackMoves = [];
  const whiteMoves = [];
  moveOwners.forEach((player, idx) => {
    if (player === blackFinal) blackMoves.push(idx + 1);
    else if (player === whiteFinal) whiteMoves.push(idx + 1);
  });

  return { moveOwners, blackMoves, whiteMoves, swap: swapRaw };
}

document.getElementById("clearBtn").addEventListener("click", () => {
  document.getElementById("tournamentId").value = "";
});


// swap解析
function analyzeSwap(g){
  if (g.rule === 25) {           // Taraguchi-10
    return analyzeTaraguchi(g);
  } else if (g.rule === 24) {    // Soosrv
    return analyzeSoosrv(g);
  } else if (g.rule === 1 || g.rule === 5) {  // RIF
    return analyzeRIF(g);
  } else {
    // 未対応ルール → Taraguchi と同じに処理
    return analyzeTaraguchi(g);
  }
}


// 例: h8 -> {x:7, y:7} （0-indexed）
function coordToIndex(pos){
    const col = pos[0].toLowerCase(); // 'a'～'o'
    const row = parseInt(pos.slice(1),10); // 1～15
    const x = col.charCodeAt(0) - "a".charCodeAt(0);
    const y = row - 1;
    return {x, y};
}

// 盤面配列に変換（5手目まで）
function movesToBoard(moves){
    const size = 15;
    const board = Array.from({length:size}, ()=>Array(size).fill(null));
    moves.forEach((playerMove,i)=>{
        if(!playerMove || playerMove === "-") return;
        const {x, y} = coordToIndex(playerMove);
        board[y][x] = i%2===0 ? "B" : "W"; // 0-indexで黒白
    });
    return board;
}

// 正規化キーを作成（回転反転考慮）
function normalizeBoard(board){
    const size = board.length;

    function rotate90(b){
        const newB = Array.from({length:size},()=>Array(size).fill(null));
        for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
                newB[x][size-1-y] = b[y][x];
            }
        }
        return newB;
    }

    function flipH(b){
        return b.map(row => [...row].reverse());
    }

    function flipV(b){
        return [...b].reverse();
    }

    function boardToString(b){
        return b.map(row=>row.map(c=>c||"-").join("")).join("/");
    }

    let boards = [];
    let b = board;
    for(let i=0;i<4;i++){ // 0°,90°,180°,270°
        boards.push(boardToString(b));
        boards.push(boardToString(flipH(b)));
        b = rotate90(b);
    }

    // 最小文字列をキーにする
    return boards.sort()[0];
}



// 5手目集計及び同一局面の判定
function getTop5MovesNormalized(games){
    const countMap = {};
    games.forEach(g=>{
        const swapInfo = analyzeSwap(g);
        const movesRaw = g.moves.split(/\s+/).slice(0,5); // 元の座標文字列
        const board = movesToBoard(movesRaw);             // 盤面配列に変換（ここは不要でもOK）
        const key = normalizeBoard(board);
        countMap[key] = countMap[key] || {count:0, moves: movesRaw};
        countMap[key].count++;
    });

    return Object.values(countMap)
                 .sort((a,b)=>b.count-a.count)
                 .slice(0,10);
}

// 描画範囲
function getBoardBounds(moves){
    let minX = 14, maxX = 0, minY = 14, maxY = 0;
    moves.forEach(m=>{
        if(!m || m === "-") return;
        const {x, y} = coordToIndex(m);
        if(x < minX) minX = x;
        if(x > maxX) maxX = x;
        if(y < minY) minY = y;
        if(y > maxY) maxY = y;
    });
    return {minX, maxX, minY, maxY};
}

function drawBoard(container, moves){
    const bounds = getBoardBounds(moves);
    let sizeX = bounds.maxX - bounds.minX + 1;
    let sizeY = bounds.maxY - bounds.minY + 1;
    const margin = 2; // 2路分余白
    sizeX += margin*2;
    sizeY += margin*2;
    const cell = 20; // 線間隔

    const board = document.createElement("div");
    board.style.position="relative";
    board.style.width = `${cell*(sizeX-1)}px`; // 線の交点数は size-1 区間
    board.style.height = `${cell*(sizeY-1)}px`;
    board.style.border="1px solid #000";
    board.style.background="#F9EBCF";

    // 縦線
    for(let i=0;i<sizeX;i++){
        const v = document.createElement("div");
        v.style.position="absolute";
        v.style.left = `${i*cell}px`;
        v.style.top = "0";
        v.style.width = "1px";
        v.style.height = "100%";
        v.style.background="#000";
        board.appendChild(v);
    }

    // 横線
    for(let i=0;i<sizeY;i++){
        const h = document.createElement("div");
        h.style.position="absolute";
        h.style.top = `${i*cell}px`;
        h.style.left = "0";
        h.style.width = "100%";
        h.style.height = "1px";
        h.style.background="#000";
        board.appendChild(h);
    }

    // 石描画（交点上に置く）
    moves.forEach((m,i)=>{
        if(!m || m === "-") return;
        const {x: origX, y: origY} = coordToIndex(m);
        const x = origX - bounds.minX + margin;
        const y = sizeY - 1 - (origY - bounds.minY + margin); // 上下反転

        const stone = document.createElement("div");
        stone.style.position="absolute";
        stone.style.width=`${cell-4}px`;
        stone.style.height=`${cell-4}px`;
        stone.style.borderRadius="50%";
        stone.style.background = i%2===0?"black":"white";
        stone.style.left = `${x*cell - (cell-4)/2}px`;
        stone.style.top = `${y*cell - (cell-4)/2}px`;
        board.appendChild(stone);

        const label = document.createElement("div");
        label.textContent = (i+1).toString();
        label.style.position="absolute";
        label.style.left = `${x*cell}px`;
        label.style.top = `${y*cell}px`;
        label.style.fontSize = "12px";
        label.style.color = i%2===0?"white":"black";
        label.style.fontWeight = "bold";
        label.style.textAlign = "center";
        label.style.lineHeight = "1";
        label.style.transform = "translate(-50%, -50%)";
        board.appendChild(label);
    });

    container.appendChild(board);
}



// 大会集計後に5手目までランキング描画を呼び出す
// 共通: Top5を描画する
// pids が指定されていれば「そのプレイヤー別の勝敗集計」も追加表示する
function renderTop5Moves(filteredGames, containerId, pids = null) {
  const container = document.getElementById(containerId);
  container.innerHTML = "";

  const top5Moves = getTop5MovesNormalized(filteredGames);
  if (!top5Moves || top5Moves.length === 0) {
    container.innerHTML = "Top5 착수는 발견되지 않았습니다";
    return;
  }

  top5Moves.forEach((item, i) => {
    const wrapper = document.createElement("div");
    wrapper.style.marginBottom = "20px";
    wrapper.style.display = "flex";
    wrapper.style.alignItems = "flex-start";

    // 左側: 盤面
    const boardDiv = document.createElement("div");
    const title = document.createElement("div");
    title.textContent = `${i + 1}위: ${item.count}회`;
    boardDiv.appendChild(title);
    drawBoard(boardDiv, item.moves);

    // 該当ゲームを取得
    const key = normalizeBoard(movesToBoard(item.moves));
    const gamesForThisKey = filteredGames.filter(g => {
      const gKey = normalizeBoard(movesToBoard(g.moves.split(/\s+/).slice(0, 5)));
      return gKey === key;
    });

    // 勝敗集計（全体）
    let blackWins = 0, whiteWins = 0, draws = 0;

    // プレイヤー別集計（複数対応）
    const playerResults = {};
    if (Array.isArray(pids)) {
      pids.forEach(pid => {
        let name = pid;
        if (allPlayers[pid]) name = allPlayers[pid].surname + " " + allPlayers[pid].name;
        playerResults[pid] = { name, wins: 0, loses: 0, draws: 0 };
      });
    }

    gamesForThisKey.forEach(g => {
      // 全体集計
      if (g.bresult == 1) blackWins++;
      else if (g.bresult == 0) whiteWins++;
      else if (g.bresult == 0.5) draws++;

      // プレイヤー別集計
      if (Array.isArray(pids)) {
        pids.forEach(pid => {
          const isBlack = g.black === pid;
          const isWhite = g.white === pid;

          if (isBlack && g.bresult == 1) playerResults[pid].wins++;
          else if (isWhite && g.bresult == 0) playerResults[pid].wins++;
          else if ((isBlack && g.bresult == 0) || (isWhite && g.bresult == 1)) playerResults[pid].loses++;
          else if (g.bresult == 0.5 && (isBlack || isWhite)) playerResults[pid].draws++;
        });
      }
    });

    // 左側盤面の下に勝敗表示（比率付き）
    const totalGamesForType = blackWins + whiteWins + draws;
    const resultDiv = document.createElement("div");
    resultDiv.style.marginTop = "5px";
    resultDiv.textContent = `흑: ${blackWins}승 (${totalGamesForType ? ((blackWins/totalGamesForType)*100).toFixed(1) : 0}%), 백: ${whiteWins}승 (${totalGamesForType ? ((whiteWins/totalGamesForType)*100).toFixed(1) : 0}%), 무승부: ${draws}회 (${totalGamesForType ? ((draws/totalGamesForType)*100).toFixed(1) : 0}%)`;
    boardDiv.appendChild(resultDiv);

    // ★ プレイヤー別集計を追加表示（比率付き）
    if (Array.isArray(pids)) {
      Object.values(playerResults).forEach(pr => {
        const totalGamesForPlayer = pr.wins + pr.loses + pr.draws;
        if (totalGamesForPlayer === 0) return; // 대국 없음 → 표시 안 함
        const div = document.createElement("div");
        div.style.marginTop = "3px";
        div.style.fontWeight = "bold";
        div.textContent = `${pr.name} → 승:${pr.wins} (${((pr.wins/totalGamesForPlayer)*100).toFixed(1)}%), 패:${pr.loses} (${((pr.loses/totalGamesForPlayer)*100).toFixed(1)}%), 무:${pr.draws} (${((pr.draws/totalGamesForPlayer)*100).toFixed(1)}%)`;
        boardDiv.appendChild(div);
      });
    }

    // 右側: 該当ゲーム一覧
    const listDiv = document.createElement("div");
    listDiv.style.marginLeft = "20px";
    const ul = document.createElement("ul");

    gamesForThisKey.forEach(g => {
      const li = document.createElement("li");
      const url = `https://www.renju.net/tournament/${g.tournament}/game/${g.id}/`;
      // ★ 日本語+英語併記
      const entry = openingMap[g.opening];
      const openingName = entry ? `${entry.ja} (${entry.en})` : g.opening;
      const openingLink = `<a href="#" class="opening-link" data-opening="${g.opening}">${openingName}</a>`;
      const blackName = allPlayers[g.black] ? allPlayers[g.black].surname + " " + allPlayers[g.black].name : g.black;
      const whiteName = allPlayers[g.white] ? allPlayers[g.white].surname + " " + allPlayers[g.white].name : g.white;
      const resultText = g.bresult == 1 ? "흑 승" : g.bresult == 0 ? "백 승" : "무승부";

      // ★ swapInfo を使って黒プレイヤーが打った手目を特定
      const swapInfo = analyzeSwap(g);
      const blackMoves = [];
      swapInfo.moveOwners.forEach((owner, idx) => {
        if (owner === blackName) {
          blackMoves.push(idx + 1); // 수는 1부터 시작
        }
      });

      // 흑 플레이어 담당 수를 표기 추가
      const blackMovesText = blackMoves.length > 0 ? ` (${blackMoves.join(",")})` : "";

      li.innerHTML = `
        <a href="${url}" target="_blank">${g.id}</a> (${openingLink}) - 
        흑${blackMovesText}: ${blackName}, 백: ${whiteName} → ${resultText}
      `;
      ul.appendChild(li);
    });

    listDiv.appendChild(ul);
    wrapper.appendChild(boardDiv);
    wrapper.appendChild(listDiv);
    container.appendChild(wrapper);

  });
}






// キーワード検索処理
let currentMatches = []; // 現在の検索結果全件
let displayedCount = 0;  // 今表示している件数

function showNextBatch(existingIds = []) {
  const suggestionsDiv = document.getElementById("suggestions");

  // 最初の表示時に「全てチェック」「全て解除」ボタンを追加
  if (displayedCount === 0) {
    suggestionsDiv.innerHTML = ""; // 前の内容をリセット
    const controlsDiv = document.createElement("div");
    controlsDiv.style.marginBottom = "5px";

    const checkAllBtn = document.createElement("button");
    checkAllBtn.textContent = "全てチェック";
    checkAllBtn.addEventListener("click", () => {
      // tournamentId に全IDを反映
      const allIds = currentMatches.map(g => g.id);
      document.getElementById("tournamentId").value = allIds.join(",");
      // 表示されている分はUIも同期
      document.querySelectorAll("#suggestions input[type=checkbox]").forEach(cb => {
        cb.checked = true;
      });
    });

    const uncheckAllBtn = document.createElement("button");
    uncheckAllBtn.textContent = "全て解除";
    uncheckAllBtn.style.marginLeft = "5px";
    uncheckAllBtn.addEventListener("click", () => {
      // tournamentId を空にする
      document.getElementById("tournamentId").value = "";
      // 表示されている分はUIも同期
      document.querySelectorAll("#suggestions input[type=checkbox]").forEach(cb => {
        cb.checked = false;
      });
    });

    controlsDiv.appendChild(checkAllBtn);
    controlsDiv.appendChild(uncheckAllBtn);
    suggestionsDiv.appendChild(controlsDiv);
  }

  const nextBatch = currentMatches.slice(displayedCount, displayedCount + 10);

  nextBatch.forEach(g => {
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = g.id;
    if (existingIds.includes(g.id)) checkbox.checked = true;

    const label = document.createElement("label");
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(` ${g.name} (ID: ${g.id})`));

    const div = document.createElement("div");
    div.appendChild(label);
    suggestionsDiv.appendChild(div);

    checkbox.addEventListener("change", updateTournamentIds);
  });

  displayedCount += nextBatch.length;

  let moreBtn = document.getElementById("moreBtn");
  const remaining = currentMatches.length - displayedCount; // 残り件数

  if (remaining > 0) {
    if (!moreBtn) {
      moreBtn = document.createElement("button");
      moreBtn.id = "moreBtn";
      moreBtn.addEventListener("click", () => showNextBatch(existingIds));
      suggestionsDiv.appendChild(moreBtn);
    }
    moreBtn.textContent = `もっと見る (残り ${remaining} 件)`;
  } else if (moreBtn) {
    moreBtn.remove();
  }
}




function updateTournamentIds() {
  const inputEl = document.getElementById("tournamentId");
  const existingIds = inputEl.value
                          .split(",")
                          .map(s => s.trim())
                          .filter(s => s);

  const checkedIds = Array.from(document.querySelectorAll("#suggestions input[type=checkbox]:checked"))
                          .map(cb => cb.value);

  const newIdsSet = new Set([
    ...existingIds.filter(id => !currentMatches.some(c => String(c.id) === id)),
    ...checkedIds
  ]);

  inputEl.value = Array.from(newIdsSet).join(",");
}

document.addEventListener("DOMContentLoaded", () => {
  // キーワード入力
  document.getElementById("keyword").addEventListener("input", runSearch);

  // マッチタイプ変更
  document.querySelectorAll('input[name="matchType"]').forEach(rb => {
    rb.addEventListener("input", runSearch);
  });

  // ルールチェックボックス変更
  document.querySelectorAll('.ruleCheckbox').forEach(cb => {
    cb.addEventListener("change", runSearch);
  });

  // プレイヤーフィルタのON/OFF（大会検索用）
  document.getElementById("enablePlayerFilter").addEventListener("change", function() {
    const playerInput = document.getElementById("searchPlayerInput");
    const searchBtn   = document.getElementById("searchPlayerCandidatesBtn");
    if (this.checked) {
      playerInput.style.display = "inline-block";
      searchBtn.style.display   = "inline-block";
    } else {
      playerInput.style.display = "none";
      searchBtn.style.display   = "none";
      playerInput.value = ""; // 入力クリア
      document.getElementById("searchPlayerCandidates").innerHTML = ""; // 候補消す
      runSearch(); // 再検索
    }
  });



// 候補検索ボタン押下時（大会検索用）
document.getElementById("searchPlayerCandidatesBtn").addEventListener("click", () => {
  const nameInputs = document.getElementById("searchPlayerInput").value
    .split(",")
    .map(s => s.trim().toLowerCase())
    .filter(s => s);

  const candidateDiv = document.getElementById("searchPlayerCandidates");
  candidateDiv.innerHTML = "";

  let inputEl = document.getElementById("searchPlayerInput");
  let currentInputs = inputEl.value.split(",").map(s => s.trim()).filter(s => s);

  nameInputs.forEach(name => {
    const candidates = playerIndex[name] || [];
    if (candidates.length > 0) {
      candidateDiv.innerHTML += `<p>候補 (${name}) を選択してください:</p>`;
      candidates.forEach(pid => {
        const p = allPlayers[pid];
        const fullName = `${p.surname} ${p.name}`.trim();

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = fullName;
        cb.id = `candidate_search_${pid}`;
        cb.addEventListener("change", function() {
          let cur = inputEl.value.split(",").map(s => s.trim()).filter(s => s);

          // ★ まず曖昧入力を削除
          cur = cur.filter(x => x.toLowerCase() !== name);

          if (this.checked) {
            if (!cur.includes(fullName.toLowerCase())) {
              cur.push(fullName.toLowerCase());
            }
          } else {
            cur = cur.filter(x => x.toLowerCase() !== fullName.toLowerCase());
          }

          inputEl.value = cur.join(", ");
          runSearch(); // 選択した時点で検索更新
        });

        const label = document.createElement("label");
        label.htmlFor = cb.id;
        label.textContent = fullName;
        candidateDiv.appendChild(cb);
        candidateDiv.appendChild(label);
        candidateDiv.appendChild(document.createElement("br"));
      });
    }
  });

  // 曖昧名はここで削除しておく
  inputEl.value = currentInputs.join(", ");
});



function runSearch() {
  const keywordInput = document.getElementById("keyword");
  const tournamentInput = document.getElementById("tournamentId");
  const suggestionsDiv = document.getElementById("suggestions");
  const candidateDiv = document.getElementById("searchPlayerCandidates");

  if (!keywordInput || !tournamentInput || !suggestionsDiv) {
    console.error("DOM要素が見つかりません");
    return;
  }

  const keyword = keywordInput.value.trim();
  const playerInput = document.getElementById("searchPlayerInput").value.trim().toLowerCase();

  if (!keyword && !playerInput) {
    suggestionsDiv.innerHTML = "";
    displayedCount = 0;
    return;
  }

  const matchType = document.querySelector('input[name="matchType"]:checked')?.value || "partial";
  const partialMatch = document.getElementById("matchPartial")?.checked;
  const startMatch   = document.getElementById("matchStart")?.checked;
  const yearFrom = parseInt(document.getElementById("yearFrom")?.value) || null;
  const yearTo   = parseInt(document.getElementById("yearTo")?.value) || null;

  suggestionsDiv.innerHTML = "";
  displayedCount = 0;

  const selectedRules = Array.from(document.querySelectorAll(".ruleCheckbox:checked"))
                             .map(cb => parseInt(cb.value, 10));

  // まずキーワード・ルール・年でフィルタ
  currentMatches = allTournaments.filter(t => {
    const name = t.name.toLowerCase();
    const kw = keyword.toLowerCase();
    const ruleId = parseInt(t.rule, 10);

    // ルールチェック
    if (selectedRules.length > 0 && !selectedRules.includes(ruleId)) return false;

    // キーワード検索
    let nameMatch = !keyword;
    if (keyword) {
      if (matchType === "regex") {
        try {
          nameMatch = new RegExp(keyword, "i").test(t.name);
        } catch (e) {
          console.error("無効な正規表現です:", e);
          suggestionsDiv.innerHTML = "無効な正規表現です";
          return false;
        }
      } else {
        if (startMatch && name.startsWith(kw)) nameMatch = true;
        else if (partialMatch && name.includes(kw)) nameMatch = true;
      }
    }
    if (!nameMatch) return false;

    // 年の範囲
    const year = parseInt(t.year);
    if ((yearFrom && year < yearFrom) || (yearTo && year > yearTo)) return false;

    return true;
  });


  // ★ プレイヤー条件
  if (playerInput) {
    let names = playerInput.split(",").map(s => s.trim()).filter(s => s);

    // tournamentPlayers を利用して高速化
    currentMatches = currentMatches.filter(t => {
      const playersInTournament = tournamentPlayers[t.id] || new Set();

      if (names.length > 1) {
        return names.every(name => {
          const pids = playerIndex[name] || [];
          return pids.some(pid => playersInTournament.has(pid));
        });
      } else {
        const pids = playerIndex[names[0]] || [];
        return pids.some(pid => playersInTournament.has(pid));
      }
    });
  }

  currentMatches.sort((a, b) => parseInt(b.id, 10) - parseInt(a.id, 10));

  const existingIds = tournamentInput.value
                      .split(",")
                      .map(s => s.trim())
                      .filter(s => s);

  showNextBatch(existingIds);
}


});

document.addEventListener("DOMContentLoaded", () => {
  const analyzeBtn = document.getElementById("analyzeBtn");
  if (!analyzeBtn) {
    console.warn("analyzeBtn 를 찾을 수 없습니다");
    return;
  }

  analyzeBtn.addEventListener("click", function() {
    const tid = document.getElementById("tournamentId").value.trim();
    if (!tid) { alert("대회 ID를 입력하세요"); return; }

    const tidArray = tid.split(",").map(s => s.trim()).filter(s => s).map(Number);
    const filteredmultiple = allGames.filter(g => tidArray.includes(Number(g.tournament)));
    if (filteredmultiple.length === 0) { alert("해당 대회 없음"); return; }

    const tournamentList = tidArray.map(id => {
      const name = tournamentMap[id]?.name || `대회 ID ${id}`;
      const url = `https://www.renju.net/tournament/${id}/`;
      return `<a href="${url}" target="_blank">${name}</a>`;
    });
    const tournamentHtml = tournamentList.join(", ");

    let blackWin=0, draw=0, whiteWin=0, totalMoves=0, blackMoves=0, whiteMoves=0, drawMoves=0;
    const openingCount={}, openingWins={};
    let firstMoveWin=0, secondMoveWin=0, thirdMoveWin=0, fourthMoveWin=0, fifthMoveWin=0;
    let combo34Win=0, combo35Win=0, combo45Win=0;
    let secondDirectTotal=0, secondIndirectTotal=0;

    filteredmultiple.forEach(g => {
      const movesCount = g.moves ? g.moves.split(/\s+/).length : 0;
      totalMoves += movesCount;
      if (g.bresult === 1) { blackWin++; blackMoves+=movesCount; }
      else if (g.bresult === 0.5) { draw++; drawMoves+=movesCount; }
      else if (g.bresult === 0) { whiteWin++; whiteMoves+=movesCount; }

      openingCount[g.opening] = (openingCount[g.opening] || 0) + 1;
      openingWins[g.opening] = openingWins[g.opening] || {black:0,white:0,draw:0};
      if (g.bresult===1) openingWins[g.opening].black++;
      else if (g.bresult===0) openingWins[g.opening].white++;
      else openingWins[g.opening].draw++;

      const swapInfo = analyzeSwap(g);
      if(swapInfo.moveOwners.length >= 5){
        const blackName = allPlayers[g.black]?.surname + " " + allPlayers[g.black]?.name;
        const whiteName = allPlayers[g.white]?.surname + " " + allPlayers[g.white]?.name;
        let winner = null;
        if(g.bresult===1) winner=blackName;
        if(g.bresult===0) winner=whiteName;

        if(winner){
          if(swapInfo.moveOwners[0]===winner) firstMoveWin++;
          if(swapInfo.moveOwners[1]===winner) secondMoveWin++;
          if(swapInfo.moveOwners[2]===winner) thirdMoveWin++;
          if(swapInfo.moveOwners[3]===winner) fourthMoveWin++;
          if(swapInfo.moveOwners[4]===winner) fifthMoveWin++;
          if(swapInfo.moveOwners[2]===winner && swapInfo.moveOwners[3]===winner) combo34Win++;
          if(swapInfo.moveOwners[2]===winner && swapInfo.moveOwners[4]===winner) combo35Win++;
          if(swapInfo.moveOwners[3]===winner && swapInfo.moveOwners[4]===winner) combo45Win++;
        }
      }

      if(movesCount>=2){
        const secondMove = g.moves.split(/\s+/)[1];
        const col = secondMove[0];
        if(col==="h") secondDirectTotal++;
        else if(col==="i"||col==="g") secondIndirectTotal++;
      }
    });

    const drawRatio = (draw/filteredmultiple.length*100).toFixed(2);
    const avgTotal = (totalMoves/filteredmultiple.length).toFixed(2);
    const avgBlack = blackWin?(blackMoves/blackWin).toFixed(2):"-";
    const avgWhite = whiteWin?(whiteMoves/whiteWin).toFixed(2):"-";
    const avgDraw = draw?(drawMoves/draw).toFixed(2):"-";
    const secondDirectRatio = ((secondDirectTotal/filteredmultiple.length)*100).toFixed(2);
    const secondIndirectRatio = ((secondIndirectTotal/filteredmultiple.length)*100).toFixed(2);

    const swapCount={};
    filteredmultiple.forEach(g=>{
      if(g.swap){
        const normSwap = g.swap.replace(/R/g,"+");
        swapCount[normSwap] = (swapCount[normSwap]||0)+1;
      }
    });

    let mostSwapCount=0;
    Object.values(swapCount).forEach(c=>{ if(c>mostSwapCount) mostSwapCount=c; });
    const mostSwapPatterns = Object.entries(swapCount)
      .filter(([_,c]) => c === mostSwapCount)
      .map(([pattern,c]) => `${pattern} (${c}회)`)
      .join(", ");

    const totalGames = blackWin + whiteWin + draw;

    document.getElementById("stats").innerHTML = `
      대회: ${tournamentHtml}<br><br>
      해당 대국 수: ${filteredmultiple.length}<br>
      흑 승: ${blackWin} (${totalGames ? ((blackWin/totalGames)*100).toFixed(2) : "0.00"}%)<br>
      백 승: ${whiteWin} (${totalGames ? ((whiteWin/totalGames)*100).toFixed(2) : "0.00"}%)<br>
      무승부: ${draw} (${totalGames ? ((draw/totalGames)*100).toFixed(2) : "0.00"}%)<br><br>
      전체 평균 수: ${avgTotal}<br>
      흑 승 평균 수: ${avgBlack}<br>
      백 승 평균 수: ${avgWhite}<br>
      무승부 평균 수: ${avgDraw}<br>
      1수 착수자 승리 수: ${firstMoveWin} (${((firstMoveWin/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      2수 착수자 승리 수: ${secondMoveWin} (${((secondMoveWin/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      3수 착수자 승리 수: ${thirdMoveWin} (${((thirdMoveWin/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      4수 착수자 승리 수: ${fourthMoveWin} (${((fourthMoveWin/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      5수 착수자 승리 수: ${fifthMoveWin} (${((fifthMoveWin/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      3+4수 동일 착수자 승리 수: ${combo34Win} (${((combo34Win/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      3+5수 동일 착수자 승리 수: ${combo35Win} (${((combo35Win/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      4+5수 동일 착수자 승리 수: ${combo45Win} (${((combo45Win/(blackWin+whiteWin))*100).toFixed(2)}%)<br>
      2수 직접 착수: ${secondDirectTotal} (${secondDirectRatio}%)<br>
      2수 간접 착수: ${secondIndirectTotal} (${secondIndirectRatio}%)<br>
      최다 스왑 패턴: ${mostSwapPatterns || "-"}<br>
    `;

    // --- maxSwapPattern 정의 ---
    const maxSwapPattern = Object.keys(swapCount).reduce((a,b)=>swapCount[a]>=swapCount[b]?a:b,"");
    const matchingGames = filteredmultiple.filter(g=>{
      if(!g.swap) return false;
      const normSwap = g.swap.replace(/R/g,"+");
      return normSwap === maxSwapPattern;
    });

    const mostSwapExampleDiv = document.getElementById("mostSwapExample");
    if(matchingGames.length>0){
      const game = matchingGames[Math.floor(Math.random()*matchingGames.length)];
      const url = `https://www.renju.net/tournament/${game.tournament}/game/${game.id}/`;
      const blackName = allPlayers[game.black]?.surname+" "+allPlayers[game.black]?.name || game.black;
      const whiteName = allPlayers[game.white]?.surname+" "+allPlayers[game.white]?.name || game.white;

      const movesRaw = game.moves.split(/\s+/).slice(0,5);
      const swapInfo = analyzeSwap(game);
      const moveOwnerText = movesRaw.map((m,i)=>{
        const owner = swapInfo.moveOwners[i] || "-";
        return `${i+1}수: ${m} (${owner})`;
      }).join("<br>");

      mostSwapExampleDiv.innerHTML = `
        <p>최다 스왑 패턴 "${maxSwapPattern}" 에 해당하는 예:</p>
        <p><a href="${url}" target="_blank">대국 ID: ${game.id}</a></p>
        <p>흑: ${blackName}, 백: ${whiteName}</p>
        <p>${moveOwnerText}</p>
      `;
    } else {
      mostSwapExampleDiv.innerHTML = `<p>최다 스왑 패턴 "${maxSwapPattern}" 에 해당하는 대국이 없습니다.</p>`;
    }

    const topOpenings = Object.entries(openingCount).sort((a,b)=>b[1]-a[1]).slice(0,10);
    const tbody = document.querySelector("#openingTable tbody");
    tbody.innerHTML="";
    topOpenings.forEach((o,i)=>{
      const entry = openingMap[o[0]];
      const openingName = entry ? `${entry.ja} (${entry.en})` : o[0];
      tbody.innerHTML+=`<tr><td>${i+1}</td><td>${openingName}</td><td>${o[1]}</td></tr>`;
    });

    renderTop5Moves(filteredmultiple,"top5MovesContainer");

    const tbody2 = document.querySelector("#openingWinRateTable tbody");
    tbody2.innerHTML = "";
    Object.entries(openingWins).forEach(([id, val]) => {
      const total = val.black + val.white + val.draw;
      const entry = openingMap[id];
      const displayName = entry ? `${entry.ja} (${entry.en})` : id;
      const openingLink = `<a href="#" class="opening-link" data-opening="${id}">${displayName}</a>`;

      tbody2.innerHTML += `
        <tr>
          <td>${openingLink}</td>
          <td>${((val.black/total)*100).toFixed(2)}%</td>
          <td>${((val.white/total)*100).toFixed(2)}%</td>
          <td>${((val.draw/total)*100).toFixed(2)}%</td>
          <td>${total}</td>
        </tr>`;
    });

  }); // ← ★ click 이벤트 리스너 종료
});   // ← ★ DOMContentLoaded 종료

// 플레이어별 집계
document.getElementById("analyzePlayerBtn").addEventListener("click", function() {
  const container = document.getElementById("playerStats");
  container.innerHTML = "";

  const nameInputs = document.getElementById("playerInput").value
                      .split(",")
                      .map(s => s.trim().toLowerCase())
                      .filter(s => s);
  const tidInput = document.getElementById("tournamentId").value.trim();

  if (!nameInputs.length || !tidInput) {
    alert("플레이어 이름과 대회 ID를 입력하세요");
    return;
  }

  const tidArray = tidInput.split(",").map(s => s.trim()).filter(s => s).map(Number);

  // 후보 표시 영역 초기화
  const candidateDiv = document.getElementById("playerCandidates");
  candidateDiv.innerHTML = "";

  // 모호한 후보 처리 (여러 입력 지원)
  let ambiguousFound = false;
  const inputEl = document.getElementById("playerInput");
  let currentInputs = inputEl.value.split(",").map(s => s.trim()).filter(s => s);

  nameInputs.forEach(name => {
    const candidates = playerIndex[name] || [];
    if (candidates.length > 1) {
      const inTournament = candidates.filter(pid =>
        allGames.some(g =>
          tidArray.includes(Number(g.tournament)) &&
          (g.black === pid || g.white === pid)
        )
      );
      if (inTournament.length > 1) {
        ambiguousFound = true;
        currentInputs = currentInputs.filter(n => n.toLowerCase() !== name);
        candidateDiv.innerHTML += `<p>후보 (${name}) 를 선택하세요:</p>`;
        inTournament.forEach(pid => {
          const p = allPlayers[pid];
          const fullName = `${p.surname} ${p.name}`.trim();
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.value = fullName;
          cb.id = `candidate_${pid}`;
          cb.addEventListener("change", function() {
            let cur = inputEl.value.split(",").map(s => s.trim()).filter(s=>s);
            if (this.checked) {
              if (!cur.includes(fullName.toLowerCase())) {
                cur.push(fullName);
              }
            } else {
              cur = cur.filter(x => x.toLowerCase() !== fullName.toLowerCase());
            }
            inputEl.value = cur.join(", ");
          });
          const label = document.createElement("label");
          label.htmlFor = cb.id;
          label.textContent = fullName;
          candidateDiv.appendChild(cb);
          candidateDiv.appendChild(label);
          candidateDiv.appendChild(document.createElement("br"));
        });
      }
    }
  });

  if (ambiguousFound) {
    inputEl.value = currentInputs.join(", ");
    return; // 사용자 선택 대기
  }

  const selectedPids = nameInputs.flatMap(name => playerIndex[name] || []);

  if (!selectedPids.length) {
    alert("해당 플레이어를 찾을 수 없습니다");
    return;
  }

  const filteredGames = allGames.filter(g => {
    if (tidArray.length && !tidArray.includes(Number(g.tournament))) return false;
    const gamePlayers = [g.black, g.white];
    if (nameInputs.length === 1) {
      return selectedPids.some(pid => gamePlayers.includes(pid));
    } else {
      for (let i = 0; i < selectedPids.length; i++) {
        for (let j = i + 1; j < selectedPids.length; j++) {
          if ([selectedPids[i], selectedPids[j]].every(pid => gamePlayers.includes(pid))) return true;
        }
      }
      return false;
    }
  });

  if (!filteredGames.length) {
    alert("해당 대회에 대국 없음");
    return;
  }

  const actualPids = Array.from(new Set(filteredGames.flatMap(g => [g.black, g.white])))
                           .filter(pid => selectedPids.includes(pid));

  if (!actualPids.length) {
    alert("해당 플레이어의 대국 없음");
    return;
  }

  proceedAnalysis(actualPids, filteredGames);

  function proceedAnalysis(pids, games) {
    const statsByPlayer = {};

    pids.forEach(pid => {
      const nameObj = allPlayers[pid];
      const playerName = nameObj.surname + " " + nameObj.name;

      const s = {
        blackWin:0, whiteWin:0, blackLose:0, whiteLose:0, blackDraw:0, whiteDraw:0,
        blackWinMoves:0, whiteWinMoves:0, blackLoseMoves:0, whiteLoseMoves:0,
        blackDrawMoves:0, whiteDrawMoves:0, opening3Count:{}, secondDirect:0, secondIndirect:0
      };

      let firstMoveWin=0, secondMoveWin=0, thirdMoveWin=0, fourthMoveWin=0, fifthMoveWin=0;
      let combo34Win=0, combo35Win=0, combo45Win=0;

      games.forEach(g => {
        if (!(g.black===pid || g.white===pid)) return;

        const moves = g.moves ? g.moves.split(/\s+/) : [];
        const movesCount = moves.length;
        const swapInfo = analyzeSwap(g);

        const isBlack = g.black === pid;
        const isWhite = g.white === pid;

        if (isBlack && g.bresult===1) { s.blackWin++; s.blackWinMoves+=movesCount; }
        if (isWhite && g.bresult===0) { s.whiteWin++; s.whiteWinMoves+=movesCount; }
        if (isBlack && g.bresult===0) { s.blackLose++; s.blackLoseMoves+=movesCount; }
        if (isWhite && g.bresult===1) { s.whiteLose++; s.whiteLoseMoves+=movesCount; }
        if (isBlack && g.bresult===0.5) { s.blackDraw++; s.blackDrawMoves+=movesCount; }
        if (isWhite && g.bresult===0.5) { s.whiteDraw++; s.whiteDrawMoves+=movesCount; }

        if (swapInfo.moveOwners.length >= 3 && swapInfo.moveOwners[2] === playerName) {
          const entry = openingMap[g.opening];
          const openingName = entry ? `${entry.ja} (${entry.en})` : g.opening;
          s.opening3Count[openingName] = (s.opening3Count[openingName] || 0) + 1;
        }

        if (movesCount>=2 && swapInfo.moveOwners[1]===playerName) {
          const col = moves[1][0];
          if (col==='h') s.secondDirect++;
          else if (col==='i'||col==='g') s.secondIndirect++;
        }

        const winnerName = g.bresult===1 ? allPlayers[g.black].surname+" "+allPlayers[g.black].name
                         : g.bresult===0 ? allPlayers[g.white].surname+" "+allPlayers[g.white].name
                         : null;
        const playerWon = winnerName===playerName;

        if (swapInfo.moveOwners.length>=5){
          if(swapInfo.moveOwners[0]===playerName && playerWon) firstMoveWin++;
          if(swapInfo.moveOwners[1]===playerName && playerWon) secondMoveWin++;
          if(swapInfo.moveOwners[2]===playerName && playerWon) thirdMoveWin++;
          if(swapInfo.moveOwners[3]===playerName && playerWon) fourthMoveWin++;
          if(swapInfo.moveOwners[4]===playerName && playerWon) fifthMoveWin++;

          if(swapInfo.moveOwners[2]===playerName && swapInfo.moveOwners[3]===playerName && playerWon) combo34Win++;
          if(swapInfo.moveOwners[2]===playerName && swapInfo.moveOwners[4]===playerName && playerWon) combo35Win++;
          if(swapInfo.moveOwners[3]===playerName && swapInfo.moveOwners[4]===playerName && playerWon) combo45Win++;
        }
      });

      const totalGames = games.filter(g => g.black===pid || g.white===pid).length;
      const totalWin  = s.blackWin + s.whiteWin;
      const totalLose = s.blackLose + s.whiteLose;
      const totalDraw = s.blackDraw + s.whiteDraw;

      const opening3List = Object.entries(s.opening3Count)
        .map(([k,v]) => `${k}(${v})`)
        .join(", ");

      statsByPlayer[playerName] = {
        s, totalWin, totalLose, totalDraw, totalGames, pid, opening3List,
        firstMoveWin, secondMoveWin, thirdMoveWin, fourthMoveWin, fifthMoveWin,
        combo34Win, combo35Win, combo45Win
      };
    });

    container.innerHTML = "";

    Object.entries(statsByPlayer).forEach(([playerName, data]) => {
      const { s, totalWin, totalLose, totalDraw, totalGames, pid, opening3List,
              firstMoveWin, secondMoveWin, thirdMoveWin, fourthMoveWin, fifthMoveWin,
              combo34Win, combo35Win, combo45Win } = data;

      if (totalGames === 0) return;

      const div = document.createElement("div");
      div.id = `playerStats_${pid}`;
      div.style.border = "1px solid #ccc";
      div.style.padding = "10px";
      div.style.marginBottom = "20px";

      const flexContainer = document.createElement("div");
      flexContainer.style.display = "flex";
      flexContainer.style.flexWrap = "wrap";
      flexContainer.style.gap = "20px";
      div.appendChild(flexContainer);

      // 누적 승패 테이블
      const summaryTable = document.createElement("table");
      summaryTable.style.borderCollapse = "collapse";
      summaryTable.style.width = "300px";
      summaryTable.innerHTML = `
        <thead>
          <tr><th>${playerName}<BR> 기준 누적 승패</th></tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <span style="color:green">승: ${totalWin} (${((totalWin/totalGames)*100).toFixed(1)}%)</span> /<br>
              <span style="color:red">패: ${totalLose} (${((totalLose/totalGames)*100).toFixed(1)}%)</span> /<br>
              <span style="color:blue">무승부: ${totalDraw} (${((totalDraw/totalGames)*100).toFixed(1)}%)</span><br>
              (총 ${totalGames}국)<br>
              <span style="color:purple">승점: ${totalWin + totalDraw*0.5} (${(((totalWin + totalDraw*0.5)/totalGames)*100).toFixed(1)}%)</span>
            </td>
          </tr>
        </tbody>
      `;
      flexContainer.appendChild(summaryTable);

      // 상세 통계
      const statsDiv = document.createElement("div");
      statsDiv.style.flex = "1 1 300px";
      statsDiv.innerHTML = `
        플레이어: ${playerName} (id=${pid})<br>
        흑 승: ${s.blackWin}<br>
        백 승: ${s.whiteWin}<br>
        흑 패: ${s.blackLose}<br>
        백 패: ${s.whiteLose}<br>
        흑 승 평균 수: ${s.blackWin ? (s.blackWinMoves/s.blackWin).toFixed(1) : "-"}<br>
        백 승 평균 수: ${s.whiteWin ? (s.whiteWinMoves/s.whiteWin).toFixed(1) : "-"}<br>
        흑 패 평균 수: ${s.blackLose ? (s.blackLoseMoves/s.blackLose).toFixed(1) : "-"}<br>
        백 패 평균 수: ${s.whiteLose ? (s.whiteLoseMoves/s.whiteLose).toFixed(1) : "-"}<br>
        흑 무승부 평균 수: ${s.blackDraw ? (s.blackDrawMoves/s.blackDraw).toFixed(1) : "-"}<br>
        백 무승부 평균 수: ${s.whiteDraw ? (s.whiteDrawMoves/s.whiteDraw).toFixed(1) : "-"}<br>
        3수 착수 패턴 (등장 횟수): ${opening3List}<br>
        2수 직접 착수: ${s.secondDirect}<br>
        2수 간접 착수: ${s.secondIndirect}<br>
        1수 착수자 승리 수: ${firstMoveWin} (${totalWin?((firstMoveWin/totalWin)*100).toFixed(2):"0.00"}%)<br>
        2수 착수자 승리 수: ${secondMoveWin} (${totalWin?((secondMoveWin/totalWin)*100).toFixed(2):"0.00"}%)<br>
        3수 착수자 승리 수: ${thirdMoveWin} (${totalWin?((thirdMoveWin/totalWin)*100).toFixed(2):"0.00"}%)<br>
        4수 착수자 승리 수: ${fourthMoveWin} (${totalWin?((fourthMoveWin/totalWin)*100).toFixed(2):"0.00"}%)<br>
        5수 착수자 승리 수: ${fifthMoveWin} (${totalWin?((fifthMoveWin/totalWin)*100).toFixed(2):"0.00"}%)<br>
        3+4수 동일 착수자 승리 수: ${combo34Win} (${totalWin?((combo34Win/totalWin)*100).toFixed(2):"0.00"}%)<br>
        3+5수 동일 착수자 승리 수: ${combo35Win} (${totalWin?((combo35Win/totalWin)*100).toFixed(2):"0.00"}%)<br>
        4+5수 동일 착수자 승리 수: ${combo45Win} (${totalWin?((combo45Win/totalWin)*100).toFixed(2):"0.00"}%)<br>
      `;
      flexContainer.appendChild(statsDiv);

      // 대국 목록 테이블
      const table = document.createElement("table");
      table.style.borderCollapse = "collapse";
      table.style.width = "100%";
      table.style.marginTop = "10px";
      table.innerHTML = `
  <thead>
    <tr>
      <th>링크</th>
      <th>포석</th>
      <th>대국자</th>
      <th>결과</th>
      <th>${playerName} 기준 승패</th>
    </tr>
  </thead>
  <tbody>
 ${games.filter(g => g.black===pid || g.white===pid).map(g=>{
  const url = `https://www.renju.net/tournament/${g.tournament}/game/${g.id}/`;
  const players = `${allPlayers[g.black].surname} ${allPlayers[g.black].name} vs ${allPlayers[g.white].surname} ${allPlayers[g.white].name}`;
  const result = g.bresult===1 ? "흑 승" : g.bresult===0 ? "백 승" : "무승부";

  const entry = openingMap[g.opening];
  const openingName = entry ? `${entry.ja} (${entry.en})` : g.opening;

  const swapInfo = analyzeSwap(g);
  const thirdMover = (swapInfo.moveOwners[2] || "").trim().toLowerCase();
  const thisPlayer = playerName.trim().toLowerCase();

  const openingHighlight = (thirdMover === thisPlayer)
    ? " style='background-color:yellow;'" : "";

  let playerRecord="", color="";
  if (g.bresult===0.5) { playerRecord="무승부"; color="blue"; }
  else if ((g.black===pid && g.bresult===1) || (g.white===pid && g.bresult===0)) { playerRecord="승"; color="green"; }
  else { playerRecord="패"; color="red"; }

  return `<tr>
    <td><a href="${url}" target="_blank">${g.id}</a></td>
    <td${openingHighlight}>${openingName}</td>
    <td>${players}</td>
    <td>${result}</td>
    <td><span style="color:${color}">${playerRecord}</span></td>
  </tr>`;
}).join('')}

  </tbody>

      `;
      div.appendChild(table);

      // Excel 출력 버튼
      const excelBtn = document.createElement("button");
      excelBtn.textContent = playerName + " 결과를 Excel로 저장";
      excelBtn.style.display = "block";
      excelBtn.style.marginTop = "10px";
      excelBtn.addEventListener("click", () => {
        const tables = div.querySelectorAll("table");
        if (!tables.length) { alert("출력할 테이블이 없습니다"); return; }

        const wb = XLSX.utils.book_new();
        tables.forEach((table, idx) => {
          const ws = XLSX.utils.table_to_sheet(table);
          if(!ws['!cols']) ws['!cols'] = [];
          ws['!cols'][0] = { wch: 50 };
          ws['!cols'][1] = { wch: 80 };
          XLSX.utils.book_append_sheet(wb, ws, "Sheet" + (idx+1));
        });
        XLSX.writeFile(wb, playerName + "_stats.xlsx");
      });
      div.appendChild(excelBtn);

      // 저장 버튼 + 설명
      const saveContainer = document.createElement("div");
      saveContainer.style.display = "flex";
      saveContainer.style.alignItems = "center";
      saveContainer.style.gap = "10px";

      const saveBtn = document.createElement("button");
      saveBtn.textContent = playerName + " 결과를 이미지로 저장";
      saveBtn.addEventListener("click", () => {
        saveBtn.style.display = "none";
        excelBtn.style.display = "none";
        html2canvas(div, { scale: 2 }).then(canvas => {
          const link = document.createElement("a");
          link.download = playerName + "_stats.png";
          link.href = canvas.toDataURL("image/png");
          link.click();
          setTimeout(() => {
            saveBtn.style.display = "block";
            excelBtn.style.display = "block";
          }, 5000);
        });
      });
      saveContainer.appendChild(saveBtn);

      const note = document.createElement("span");
      note.textContent = "※ 포석 칸이 노란색인 경우 해당 플레이어가 3수를 착수한 대국";
      note.style.fontSize = "20px";
      note.style.color = "gray";
      saveContainer.appendChild(note);

      div.appendChild(saveContainer);

      container.appendChild(div);
      renderTop5Moves(games, "tournamentplayerTop5MovesContainer", [pid]);
    });
  }
});




// 스왑 이력 검색 (플레이어 이름 또는 포석 이름)
document.getElementById("searchSwapBtn").addEventListener("click", function () {
  const inputEl = document.getElementById("swapPlayerInput");
  const nameOrOpeningInput = inputEl.value.trim().toLowerCase();
  const tid = document.getElementById("tournamentId").value.trim();

  if (!nameOrOpeningInput || !tid) {
    alert("플레이어 이름 또는 포석 이름과 대회 ID를 입력하세요");
    return;
  }

  const tidArray = tid.split(",").map(s => s.trim()).filter(s => s).map(Number);

  // 플레이어 후보 검색
  const candidates = playerIndex[nameOrOpeningInput] || [];
  const candidateDiv = document.getElementById("swapResult");
  candidateDiv.innerHTML = "";

  // 플레이어 후보가 없으면 → 포석 검색으로 간주
  if (candidates.length === 0) {
    runOpeningSearch(nameOrOpeningInput, tidArray);
    return;
  }

  // ★ 대회 참가자로 필터링
  const tournamentCandidates = candidates.filter(pid =>
    allGames.some(g =>
      tidArray.includes(Number(g.tournament)) &&
      (g.black === pid || g.white === pid)
    )
  );

  if (tournamentCandidates.length === 0) {
    alert("해당 대회에 대국 없음");
    return;
  }

  // ★ 대회 참가자가 한 명뿐이면 바로 검색
  if (tournamentCandidates.length === 1) {
    runSwapSearch(tournamentCandidates[0], tidArray);
    return;
  }

  // 모호한 후보가 여러 명 → 체크박스로 선택
  candidateDiv.innerHTML += `<p>후보 (${nameOrOpeningInput}) 를 선택하세요:</p>`;
  tournamentCandidates.forEach(pid => {
    const p = allPlayers[pid];
    const fullName = `${p.surname} ${p.name}`.trim();

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.value = pid;
    cb.id = `swap_candidate_${pid}`;
    cb.addEventListener("change", function () {
      if (this.checked) {
        inputEl.value = fullName.toLowerCase();
        runSwapSearch(pid, tidArray);
      }
    });

    const label = document.createElement("label");
    label.htmlFor = cb.id;
    label.textContent = fullName;
    candidateDiv.appendChild(cb);
    candidateDiv.appendChild(label);
    candidateDiv.appendChild(document.createElement("br"));
  });
  return; // ★ 선택 대기
});


// --- 플레이어 검색 처리 ---
function runSwapSearch(pid, tidArray) {
  const filteredmultiple = allGames.filter(
    g => tidArray.includes(Number(g.tournament)) && (g.black === pid || g.white === pid)
  );

  if (filteredmultiple.length === 0) {
    alert("해당 대회에 대국 없음");
    return;
  }

  const playerName = (allPlayers[pid].surname + " " + allPlayers[pid].name).trim().toLowerCase();

  renderSwapTable(filteredmultiple, playerName, true);
}


// --- 포석 검색 처리 ---
function runOpeningSearch(openingNameInput, tidArray) {
  const filteredmultiple = allGames.filter(g => {
    if (!tidArray.includes(Number(g.tournament))) return false;

    const entry = openingMap[g.opening];
    if (!entry) return false;

    const jaName = entry.ja.toLowerCase();
    const enName = entry.en.toLowerCase();
    return (openingNameInput === jaName || openingNameInput === enName);
  });

  if (filteredmultiple.length === 0) {
    alert("해당 대회에 해당 포석 없음");
    return;
  }

  renderSwapTable(filteredmultiple, null, false); // ★ 하이라이트 비활성화
}


// --- 공통 테이블 렌더링 ---
function renderSwapTable(games, playerName, enableHighlight) {
  let tableHtml = `
    <table border="1" style="border-collapse:collapse; margin-top:10px; width:100%;">
      <thead>
        <tr>
          <th>게임</th>
          <th>포석</th>
          <th>스왑</th>
          <th>2수 유형</th>
          <th>1수</th>
          <th>2수</th>
          <th>3수</th>
          <th>4수</th>
          <th>5수</th>
        </tr>
      </thead>
      <tbody>
  `;

  games.forEach(g => {
    const swapInfo = analyzeSwap(g);
    const moves = g.moves.split(/\s+/);
    const second = moves[1] || "";
    let type = "";
    if (second) {
      const col = second[0];
      if (col === "h") type = "직접";
      else if (col === "i" || col === "g") type = "간접";
    }
    const url = `https://www.renju.net/tournament/${g.tournament}/game/${g.id}/`;

    // ★ openingMap → 한국어 그대로 (ja/en 병기 유지)
    const entry = openingMap[g.opening];
    const openingName = entry ? `${entry.ja} (${entry.en})` : g.opening;

    // ★ 하이라이트 처리 (플레이어 검색 전용)
    const thirdMover = (swapInfo.moveOwners[2] || "").trim().toLowerCase();
    const openingHighlight = (enableHighlight && thirdMover === playerName)
      ? " style='background-color:yellow;'" : "";

    tableHtml += `
      <tr>
        <td><a href="${url}" target="_blank">${g.id}</a></td>
        <td${openingHighlight}>${openingName}</td>
        <td>${swapInfo.swap.replace(/R/g, "+")}</td>
        <td>${type}</td>
        <td>${swapInfo.moveOwners[0] || ""}</td>
        <td>${swapInfo.moveOwners[1] || ""}</td>
        <td>${swapInfo.moveOwners[2] || ""}</td>
        <td>${swapInfo.moveOwners[3] || ""}</td>
        <td>${swapInfo.moveOwners[4] || ""}</td>
      </tr>
    `;
  });

  tableHtml += `</tbody></table>`;
  document.getElementById("swapResult").innerHTML = tableHtml;
}

// 자주 등장하는 기보 랭킹의 포석 팝업 처리
document.addEventListener("click", function(e){
  if(e.target.classList.contains("opening-link")){
    e.preventDefault();

    // ★ data-opening 에는 ID가 들어 있음
    const openingId = e.target.dataset.opening;

    const tidArray = document.getElementById("tournamentId").value
                       .split(",").map(s=>s.trim()).filter(s=>s).map(Number);

    // ★ ID로 필터링
    const openingGames = allGames.filter(g => 
      tidArray.includes(Number(g.tournament)) &&
      String(g.opening) === String(openingId)
    );

    // ★ 표시 이름 구성 (일본어 + 영어 병기 유지)
    const entry = openingMap[openingId];
    const openingName = entry ? `${entry.ja} (${entry.en})` : openingId;

    // --- 요약 영역과 랭킹 영역 초기화
    const summaryDiv = document.getElementById("openingSummary");
    const top10Div = document.getElementById("openingTop10");
    summaryDiv.innerHTML = "";
    top10Div.innerHTML = "";

    // --- 승패 요약 계산
    let blackWins = 0, whiteWins = 0, draws = 0;
    openingGames.forEach(g => {
      if (g.bresult == 1) blackWins++;
      else if (g.bresult == 0) whiteWins++;
      else if (g.bresult == 0.5) draws++;
    });
    const total = blackWins + whiteWins + draws;
    const blackPct = total ? ((blackWins/total)*100).toFixed(1) : 0;
    const whitePct = total ? ((whiteWins/total)*100).toFixed(1) : 0;
    const drawPct  = total ? ((draws/total)*100).toFixed(1) : 0;

    // --- 요약 표시
    summaryDiv.innerHTML = `
      <div style="margin-bottom:10px; font-weight:bold;">
        해당 포석: ${openingName} → 
        <span style="color:green;">흑 ${blackWins}승 (${blackPct}%)</span>, 
        <span style="color:red;">백 ${whiteWins}승 (${whitePct}%)</span>, 
        <span style="color:blue;">무승부 ${draws} (${drawPct}%)</span>
      </div>
    `;

    // --- 랭킹 표시 (기존 함수 사용)
    renderTop5Moves(openingGames, "openingTop10");

    // 모달 표시
    document.getElementById("modalOverlay").style.display = "block";
    document.getElementById("openingPopup").style.display = "block";
  }
});

// 닫기 처리
document.getElementById("closeOpeningPopup").addEventListener("click", () => {
  document.getElementById("openingPopup").style.display = "none";
  document.getElementById("modalOverlay").style.display = "none";
});
document.getElementById("modalOverlay").addEventListener("click", () => {
  document.getElementById("openingPopup").style.display = "none";
  document.getElementById("modalOverlay").style.display = "none";
});






</script>
</body>
</html>
